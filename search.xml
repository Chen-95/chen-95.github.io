<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019前端面试总结，看完弄懂，工资少说加3K]]></title>
    <url>%2F2019%2F03%2F11%2F2019%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%EF%BC%8C%E7%9C%8B%E5%AE%8C%E5%BC%84%E6%87%82%EF%BC%8C%E5%B7%A5%E8%B5%84%E5%B0%91%E8%AF%B4%E5%8A%A03K%2F</url>
    <content type="text"><![CDATA[前言文章涉及的内容可能不全面，但量很多，需要慢慢看。来源于各个地方，我花了很长的时间整理，希望对大家有帮助。但是难免会有打字的错误或理解的错误，希望发现的可以邮箱告诉我clh950818@163.com，我会及时的进行修改，旨在能帮到大家，谢谢。文章目录HTML相关CSS相关JavaScript相关DOM相关HTTP相关VUE相关算法相关网络安全相关webpack相关其他一、HTML相关1. html语义化意义：根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。 注意：尽可能少的使用无语义的标签div和span；在语义不明显时，既可以使用div或者p时，尽量用p,因为p在默认情况下有上下间距，对兼容特殊终端有利；不要使用纯样式标签，如：b、font、u等，改用css设置。需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；表单域要用fieldset标签包起来，并用legend标签说明表单的用途；每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。新标签：2. meta viewport相关1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt; H5标准声明，使用 HTML5 doctype，不区分大小写&lt;head lang=”en”&gt; 标准的 lang 属性写法&lt;meta charset=’utf-8′&gt; 声明文档使用的字符编码&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt; 优先使用 IE 最新版本和 Chrome&lt;meta name=”description” content=”不超过150个字符”/&gt; 页面描述&lt;meta name=”keywords” content=””/&gt; 页面关键词&lt;meta name=”author” content=”name, email@gmail.com”/&gt; 网页作者&lt;meta name=”robots” content=”index,follow”/&gt; 搜索引擎抓取&lt;meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”&gt; 为移动设备添加 viewport&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt; iOS 设备 begin&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt; 添加到主屏后的标题（iOS 6 新增）是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏&lt;meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”&gt;添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）&lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt;&lt;meta name=”format-detection” content=”telphone=no, email=no”/&gt; 设置苹果工具栏颜色&lt;meta name=”renderer” content=”webkit”&gt; 启用360浏览器的极速模式(webkit)&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt; 避免IE使用兼容模式&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt; 不让百度转码&lt;meta name=”HandheldFriendly” content=”true”&gt; 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓&lt;meta name=”MobileOptimized” content=”320″&gt; 微软的老式浏览器&lt;meta name=”screen-orientation” content=”portrait”&gt; uc强制竖屏&lt;meta name=”x5-orientation” content=”portrait”&gt; QQ强制竖屏&lt;meta name=”full-screen” content=”yes”&gt; UC强制全屏&lt;meta name=”x5-fullscreen” content=”true”&gt; QQ强制全屏&lt;meta name=”browsermode” content=”application”&gt; UC应用模式&lt;meta name=”x5-page-mode” content=”app”&gt; QQ应用模式&lt;meta name=”msapplication-tap-highlight” content=”no”&gt; windows phone 点击无高光设置页面不缓存&lt;meta http-equiv=”pragma” content=”no-cache”&gt;&lt;meta http-equiv=”cache-control” content=”no-cache”&gt;&lt;meta http-equiv=”expires” content=”0″&gt;3. canvas 相关1234567使用前需要获得上下文环境，暂不支持3d常用api: 1.fillRect(x,y,width,height)实心矩形 2.strokeRect(x,y,width,height)空心矩形 3.fillText("Hello world",200,200);实心文字 4.strokeText("Hello world",200,300)空心文字各种东西！！！新标签兼容低版本ie9之前版本通过createElement创建html5新标签引入html5shiv.js二、CSS相关1. 盒模型ie盒模型算上border、padding及自身（不算margin），标准的只算上自身窗体的大小 css设置方法如下:1234/* 标准模型 */box-sizing:content-box;/*IE模型*/box-sizing:border-box;margin、border、padding、content由外到里几种获得宽高的方式dom.style.width/height这种方式只能取到dom元素内联样式所设置的宽高，也就是说如果该节点的样式是在style标签中或外联的CSS文件中设置的话，通过这种方法是获取不到dom的宽高的。dom.currentStyle.width/height这种方式获取的是在页面渲染完成后的结果，就是说不管是哪种方式设置的样式，都能获取到。但这种方式只有IE浏览器支持。window.getComputedStyle(dom).width/height这种方式的原理和2是一样的，这个可以兼容更多的浏览器，通用性好一些。dom.getBoundingClientRect().width/height这种方式是根据元素在视窗中的绝对位置来获取宽高的dom.offsetWidth/offsetHeight这个就没什么好说的了，最常用的，也是兼容最好的。拓展 各种获得宽高的方式获取屏幕的高度和宽度（屏幕分辨率）：window.screen.height/width获取屏幕工作区域的高度和宽度（去掉状态栏）：window.screen.availHeight/availWidth网页全文的高度和宽度：document.body.scrollHeight/Width滚动条卷上去的高度和向右卷的宽度：document.body.scrollTop/scrollLeft网页可见区域的高度和宽度（不加边线）：document.body.clientHeight/clientWidth网页可见区域的高度和宽度（加边线）：document.body.offsetHeight/offsetWidth边距重叠解决方案(BFC) BFC原理内部的box会在垂直方向，一个接一个的放置 每个元素的margin box的左边，与包含块border box的左边相接触（对于从做往右的格式化，否则相反）box垂直方向的距离由margin决定，属于同一bfc的两个相邻box的margin会发生重叠bfc的区域不会与浮动区域的box重叠bfc是一个页面上的独立的容器，外面的元素不会影响bfc里的元素，反过来，里面的也不会影响外面的计算bfc高度的时候，浮动元素也会参与计算 创建bfcfloat属性不为none（脱离文档流）position为absolute或fixeddisplay为inline-block,table-cell,table-caption,flex,inine-flexoverflow不为visible根元素 demo1234567891011&lt;section class="top"&gt; &lt;h1&gt;上&lt;/h1&gt; 这块margin-bottom:30px;&lt;/section&gt;&lt;!-- 给下面这个块添加一个父元素，在父元素上创建bfc --&gt;&lt;div style="overflow:hidden"&gt; &lt;section class="bottom"&gt; &lt;h1&gt;下&lt;/h1&gt; 这块margin-top:50px; &lt;/section&gt;&lt;/div&gt;2. css reset 和 normalize.css 有什么区别两者都是通过重置样式，保持浏览器样式的一致性前者几乎为所有标签添加了样式，后者保持了许多浏览器样式，保持尽可能的一致后者修复了常见的桌面端和移动端浏览器的bug：包含了HTML5元素的显示设置、预格式化文字的font-size问题、在IE9中SVG的溢出、许多出现在各浏览器和操作系统中的与表单相关的bug。前者中含有大段的继承链后者模块化，文档较前者来说丰富3. 居中方法水平方向上针对inline, 内联块inline-block, 内联表inline-table, inline-flex元素及img,span,button等元素123.text_div&#123; text-align:center;&#125;不定宽块状元素居中123.text_div&#123; margin:0 auto;//且需要设置父级宽度&#125;通过给父元素设置 float，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。123456789.wrap&#123; float:left; position:relative; left:50%; clear:both;&#125;.wrap-center&#123; left:-50%;&#125;垂直居中单行内联(inline-)元素垂直居中通过设置内联元素的高度(height)和行高(line-height)相等，从而使元素垂直居中。1234.text_div&#123; height: 120px; line-height: 120px;&#125;利用表布局12345678.father &#123; display: table;&#125;.children &#123; display: table-cell; vertical-align: middle; text-align: center; &#125;flex布局12345.center-flex &#123; display: flex; flex-direction: column;//上下排列 justify-content: center;&#125;绝对布局方式已知高度123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; height: 100px; margin-top: -50px; &#125;未知高度12345678.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125;垂直水平居中根据上方结合flex方式12345.parent &#123; display: flex; justify-content: center; align-items: center;&#125;grid方式1234567.parent &#123; height: 140px; display: grid;&#125;.child &#123; margin: auto;&#125;4. css优先级确定每个选择器都有权值，权值越大越优先继承的样式优先级低于自身指定样式！important优先级最高 js也无法修改权值相同时，靠近元素的样式优先级高 顺序为内联样式表（标签内部）&gt; 内部样式表（当前文件中）&gt; 外部样式表（外部文件中）5. bfc内容见盒模型6. 如何清除浮动不清楚浮动会发生高度塌陷：浮动元素父元素高度自适应（父元素不写高度时，子元素写了浮动后，父元素会发生高度塌陷）clear清除浮动（添加空div法）在浮动元素下方添加空div,并给该元素写css样式： {clear:both;height:0;overflow:hidden;}给浮动元素父级设置高度父级同时浮动（需要给父级同级元素添加浮动）父级设置成inline-block，其margin: 0 auto居中方式失效给父级添加overflow:hidden 清除浮动方法万能清除法 after伪类 清浮动（现在主流方法，推荐使用）1234567891011.float_div:after&#123; content:"."; clear:both; display:block; height:0; overflow:hidden; visibility:hidden;&#125;.float_div&#123; zoom:1&#125;7. 自适应布局思路：左侧浮动或者绝对定位，然后右侧margin撑开使用div包含，然后靠负margin形成bfc使用flex8. 画三角形123456789#item &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 50px solid transparent; border-bottom: 50px solid blue; background: white;&#125;9. link @import导入csslink是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。link无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。link支持使用Javascript控制DOM去改变样式；而@import不支持。10. animation11. 长宽比方案使用padding方式结合calc实现长宽一项设置百分比另一项aspect-ratio实现（需借助插件实现）12. display相关block:div等容器类型inline:img span等行内类型table系列：将样式变成table类型flex:重点把握，非常强大grid:同上inline-block:可设置宽度，两者间有一点间隙inherit:继承父级三、JavaScript相关1. [“1”, “2”, “3”].map(parseInt)123456789101112131415161718首先, map接受两个参数, 一个回调函数 callback, 一个回调函数的this值其中回调函数接受三个参数 currentValue, index, arrary;而题目中, map只传入了回调函数--parseInt.其次, parseInt 只接受两个两个参数 string, radix(基数). 本题理解来说也就是key与 index 所以本题即问parseInt(&apos;1&apos;, 0);parseInt(&apos;2&apos;, 1);parseInt(&apos;3&apos;, 2);parseInt(string, radix)string 必需。要被解析的字符串。radix 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。2. [[3,2,1].reduce(Math.pow), [].reduce(Math.pow)]12345arr.reduce(callback[, initialValue])reduce接受两个参数, 一个回调, 一个初始值.回调函数接受四个参数 previousValue, currentValue, currentIndex, array需要注意的是 If the array is empty and no initialValue was provided, TypeError would be thrown.所以第二个表达式会报异常. 第一个表达式等价于 Math.pow(3, 2) =&gt; 9; Math.pow(9, 1) =&gt;93.123456789var ary = [0,1,2];ary[10] = 10;ary.filter(function(x) &#123; return x === undefined;&#125;);我们看到在迭代这个数组的时候, 首先检查了这个索引值是不是数组的一个属性, 那么我们测试一下.0 in ary; =&gt; true3 in ary; =&gt; false10 in ary; =&gt; true也就是说 从 3 - 9 都是没有初始化的bug !, 这些索引并不存在与数组中. 在 array 的函数调用的时候是会跳过这些坑的.4. [typeof null, null instanceof Object]123456789101112typeof 返回一个表示类型的字符串.instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上.type resultUndefined "undefined"Null "object"Boolean "boolean"Number "number"String "string"Symbol "symbol"Host object Implementation-dependentFunction "function"Object "object"5. js数据类型number;string;boolean;undefined;null;symbol（ES6新增，文章后面有对着新类型的解释）Symbol 生成一个全局唯一的值。Object.（包括Object，Array，Function）6. promise 用法123456789101112131415161718192021定义var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);使用promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;);//等价于：promise.then(function()&#123; //success&#125;).catch(function()&#123; //failure&#125;)7. es6 promise ajax123456789101112131415161718192021222324252627定义const myHttpClient = url =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; let client = new XMLHttpRequest(); client.open("GET", url); client.onreadystatechange = handler; client.responseType = "json"; client.setRequestHeader("Accept", "application/json"); client.send(); function handler() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125; &#125;);&#125;;使用myHttpClient('https://www.baidu.com').then(res =&gt; &#123; console.log(res);&#125;).catch(error =&gt; &#123; console.log(error);&#125;);8. 闭包1234567891011function foo(x) &#123; var tmp = 3; return function (y) &#123; alert(x + y + (++tmp)); &#125;&#125;var bar = foo(2); // bar 现在是一个闭包bar(10);结果是16es6通常用let const块级作用域代替，闭包缺点，ie中会引起内存泄漏，严格来说是ie的缺点不是闭包的问题9. 什么是立即执行函数？使用立即执行函数的目的是什么？1234567891011常见两种方式1.(function()&#123;...&#125;)() (function(x)&#123; console.log(x); &#125;)(12345)2.(function()&#123;...&#125;()) (function(x)&#123; console.log(x); &#125;(12345))作用 不破坏污染全局的命名空间，若需要使用，将其用变量传入如（function(window)&#123;...&#125;(window)）10. async/await 语法123456789101112131415161718192021222324252627282930作用：异步代码的新方式promise示例const makeRequest = () =&gt; &#123; return getJSON() .then(data =&gt; &#123; if (data.needsAnotherRequest) &#123; return makeAnotherRequest(data) .then(moreData =&gt; &#123; console.log(moreData) return moreData &#125;) &#125; else &#123; console.log(data) return data &#125; &#125;)&#125;async/await示例const makeRequest = async () =&gt; &#123; const data = await getJSON() if (data.needsAnotherRequest) &#123; const moreData = await makeAnotherRequest(data); console.log(moreData) return moreData &#125; else &#123; console.log(data) return data &#125;&#125;函数前面多了一个aync关键字。await关键字只能用在aync定义的函数内。async函数会隐式地返回一个promise，该promise的reosolve值就是函数return的值。(示例中reosolve值就是字符串"done")11. 深浅拷贝12345678910111213141516171819202122let a = &#123; aa: 1, bb: 2, cc: 3, dd: &#123; ee: 5, &#125;, ff: &#123; gg: 6, &#125;&#125;;let d = JSON.parse(JSON.stringify(a));//深复制包含子对象let c = &#123;...a&#125;;//拷贝一层但不包含子对象let b = a;//浅拷贝b.bb = 22;c.cc = 33;c.dd.ee = 55;d.ff.gg = 66;console.log(a);console.log(b);console.log(c);console.log(d);12. 数组去重123456思路1：定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中思路2：先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。思路3：利用对象属性存在的特性，如果没有该属性则存入新数组。思路4（最常用）：使用es6 setlet arr= [1, 2, 3, 3, 5, 7, 2, 6, 8];console.log([...new Set(arr)]);13. 正则实现trim()功能12345function myTrim(str) &#123; let reg = /^\s+|\s+$/g; return str.replace(reg, "");&#125;console.log(myTrim(' asdf '));14. JS原型每个对象都有 proto 属性，但只有函数对象才有 prototype 属性个人粗略理解与python的类方法静态方法实例方法差不多15. es6 class面向对象，java中类16. JS 如何实现继承使用原型继承（既继承了父类的模板，又继承了父类的原型对象。优点是继承了父类的模板，又继承了父类的原型对象，缺点就是父类实例传参，不是子类实例化传参，不符合常规语言的写法）使用call的方式（继承了父类的模板，不继承了父类的原型对象。优点是方便了子类实例传参，缺点就是不继承了父类的原型对象）17. 手写jquery插件1234567891011(function ($) &#123; $.fn.myPlugins = function (options) &#123; //参数赋值 options = $.extend(defaults, options);//对象合并 this.each(function () &#123; //执行代码逻辑 &#125;); &#125;;&#125;)(jQuery);$(selector).myPlugins(&#123;参数&#125;);18. 数组合并去重排序12345let arr1 = [1, 25, 2, 26, 1234, 6, 213];let arr2 = [2, 6, 2134, 6, 31, 623];let c = [...new Set([...arr1, ...arr2])].sort((a, b) =&gt; &#123; return a - b;&#125;);19. call apply作用：在函数调用时改变函数的执行上下文也就是this的值 区别：call采用不定长的参数列表，而apply使用一个参数数组。 性能优化图20. for 中setTimeOut要为循环题创建不同的循环副本21. sort函数V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort，数量小于10的数组使用 插入，比10大的数组则使用 快排。22. navigator23. jquery绑定方式click后者覆盖bind后者覆盖on(jquery&gt;=1.7)livedelegate24. 事件流向冒泡：子节点一层层冒泡到根节点捕获顺序与冒泡相反addEventListener最后个参数true代表捕获反之代表冒泡阻止冒泡不停止父节点捕获25. 原生操作class123456789101112131415161718192021//判断有无function hasClass(ele, cls) &#123; return ele.className.match(new RegExp("(\\s|^)" + cls + "(\\s|$)"));&#125;//添加function addClass(ele, cls) &#123; if (!this.hasClass(ele, cls)) ele.className += " " + cls;&#125;//删除function removeClass(ele, cls) &#123; if (hasClass(ele, cls)) &#123; let reg = new RegExp("(\\s|^)" + cls + "(\\s|$)"); ele.className = ele.className.replace(reg, " "); &#125;&#125;html5中加入classList 一系列操作兼容至IE10四、DOM相关1. dom事件模型DOM之事件模型分脚本模型、内联模型(同类一个，后者覆盖)、动态绑定(同类多个) demo12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt;&lt;!--行内绑定：脚本模型--&gt;&lt;button onclick="javascrpt:alert('Hello')"&gt;Hello1&lt;/button&gt;&lt;!--内联模型--&gt;&lt;button onclick="showHello()"&gt;Hello2&lt;/button&gt;&lt;!--动态绑定--&gt;&lt;button id="btn3"&gt;Hello3&lt;/button&gt;&lt;/body&gt;&lt;script&gt;/*DOM0：同一个元素，同类事件只能添加一个，如果添加多个，* 后面添加的会覆盖之前添加的*/function shoeHello() &#123;alert("Hello");&#125;var btn3 = document.getElementById("btn3");btn3.onclick = function () &#123;alert("Hello");&#125;/*DOM2:可以给同一个元素添加多个同类事件*/btn3.addEventListener("click",function () &#123;alert("hello1");&#125;);btn3.addEventListener("click",function () &#123;alert("hello2");&#125;)if (btn3.attachEvent)&#123;/*IE*/btn3.attachEvent("onclick",function () &#123;alert("IE Hello1");&#125;)&#125;else &#123;/*W3C*/btn3.addEventListener("click",function () &#123;alert("W3C Hello");&#125;)&#125;&lt;/script&gt;冒泡解释：当点击一个元素触发事件时. 事件会先从元素的最外层父元素一层一层进入到触发的元素, 然后在从触发元素一层一层返回到最外层父元素, 从最外层一层一层进入的阶段叫事件捕获阶段, 从最里层一层一层往外的阶段叫事件冒泡.2. 移动端触摸事件①touchstart：当手指触碰到屏幕的时候触发②touchmove：当手指在屏幕上滑动的时候触发③touchend：当手指离开屏幕的时候时候触发④touchcancel事件：当系统停止跟踪触摸的时候触发(这个事件很少会用，一般不做深入研究)。电话接入或者弹出信息等其他事件切入event：touches：表示当前跟踪的触摸操作的touch对象的数组。targetTouches：特定于事件目标的Touch对象的数组。changeTouches：表示自上次触摸以来发生了什么改变的Touch对象的数组。每个touch对象包含的属性clientX：触摸目标在视口中的x坐标。clientY：触摸目标在视口中的y坐标。identifier：标识触摸的唯一ID。pageX：触摸目标在页面中的x坐标。pageY：触摸目标在页面中的y坐标。screenX：触摸目标在屏幕中的x坐标。screenY：触摸目标在屏幕中的y坐标。target：触目的DOM节点目标。3. 事件委托参考定义：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件 好处：给重复的节点添加相同操作，减少dom交互，提高性能 实现思路：给父组件添加事件，通过事件冒泡，排查元素是否为指定元素，并进行系列操作五、HTTP相关1. 常见状态码2开头 （请求成功）表示成功处理了请求的状态代码。200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。201 （已创建） 请求成功并且服务器创建了新的资源。202 （已接受） 服务器已接受请求，但尚未处理。203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。204 （无内容） 服务器成功处理了请求，但没有返回任何内容。205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。206 （部分内容） 服务器成功处理了部分 GET 请求。3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。400 （错误请求） 服务器不理解请求的语法。401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。403 （禁止） 服务器拒绝请求。404 （未找到） 服务器找不到请求的网页。405 （方法禁用） 禁用请求中指定的方法。406 （不接受） 无法使用请求的内容特性响应请求的网页。407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。408 （请求超时） 服务器等候请求时发生超时。409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。415 （不支持的媒体类型） 请求的格式不受请求页面的支持。416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。500 （服务器内部错误） 服务器遇到错误，无法完成请求。501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。2. 缓存Expires在http1.0中使用，与服务器时间有误差，在1.1中由Cache-control替代cdn3. Cache-Control 和 Etag 的区别如下图:4. Cookie sessionStorage localStorage共同点：都是保存在浏览器端，且同源的。区别：cookie数据始终在同源的http请求中携带，即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据不能超过4k(适合保存小数据)。sessionStorage和localStorage容量较大，数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效。localStorage：始终有效，窗口或浏览器关闭也一直保存，需手动清楚；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。作用域不同。sessionStorage不在不同的浏览器窗口中共享；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。应用场景：localStorage：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage ：敏感账号一次性登录； cookies与服务器交互。5. GET POST区别请求行，请求头，请求体详解1,2,3请求行，4请求体，5请求体6. 跨域、JSONP 、CORS、postMessage跨域概念解释：当前发起请求的域与该请求指向的资源所在的域不一样。这里的域指的是这样的一个概念：我们认为若协议 + 域名 + 端口号均相同，那么就是同域。 如下表:jsonp实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849原生&lt;script&gt; var script = document.createElement('script'); script.type = 'text/javascript'; // 传参并指定回调执行函数为onBack script.src = 'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack'; document.head.appendChild(script); // 回调执行函数 function onBack(res) &#123; alert(JSON.stringify(res)); &#125; &lt;/script&gt; jquery$.ajax(&#123; url: 'http://www.domain2.com:8080/login', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: "onBack", // 自定义回调函数名 data: &#123;&#125;&#125;);vuethis.$http.jsonp('http://www.domain2.com:8080/login', &#123; params: &#123;&#125;, jsonp: 'onBack'&#125;).then((res) =&gt; &#123; console.log(res); &#125;)配合的后端node实现,其他服务器语言也可以const querystring = require('querystring');const http = require('http');const server = http.createServer();server.on('request', function(req, res) &#123; var params = qs.parse(req.url.split('?')[1]); var fn = params.callback; // jsonp返回设置 res.writeHead(200, &#123; 'Content-Type': 'text/javascript' &#125;); res.write(fn + '(' + JSON.stringify(params) + ')'); res.end();&#125;);server.listen('8080');jsoup缺点只能实现get请求CORS：跨源资源共享 Cross-Origin Resource Sharing(CORS)，通常服务器设置，若带cookie请求，则前后端都需要设置后端常见设置response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;www.domain1.com&quot;); // 若有端口需写全（协议+域名+端口），允许那些外源请求response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); //是否需要验证前端示例1234567891011121314151617181920212223原生var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open('post', 'http://www.domain2.com:8080/login', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('user=admin'); xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;jquery$.ajax(&#123; ... xhrFields: &#123; withCredentials: true // 前端设置是否带cookie &#125;, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ...&#125;);12345678910111213141516171819202122232425262728293031323334353637postMessage(data,origin)方法接受两个参数demoa.html&lt;iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); iframe.onload = function() &#123; var data = &#123; name: 'aym' &#125;; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com'); &#125;; // 接受domain2返回数据 window.addEventListener('message', function(e) &#123; alert('data from domain2 ---&gt; ' + e.data); &#125;, false);&lt;/script&gt;b.html 与a.html不同源&lt;script&gt; // 接收domain1的数据 window.addEventListener('message', function(e) &#123; alert('data from domain1 ---&gt; ' + e.data); var data = JSON.parse(e.data); if (data) &#123; data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com'); &#125; &#125;, false);&lt;/script&gt;8. osi模型七层结构：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层 tcp ucp属于传输层；http属于应用层9. http2.0 http1HTTP2.0的基本单位为二进制帧HTTP2.0中帧具有优先级HTTP2.0的多路复用（ 1次连接）HTTP2.0压缩消息头HTTP2.0服务端推送HTTP2.0只适用于HTTPS的场景六、Vue相关1. 生命周期顺序2. 组件通信父传子用props父用子用ref子调父用$emit无关系用Bus3. Vuex组件通信库，可以避免子组件无法改变props的弊端等 mutations 同步操作， 用于改变状态 官方不推荐异步 action 执行多个mutaions，官方推荐异步操作 mapState、mapGetters、mapActions使用示例123456789101112131415161718&lt;template&gt; &lt;el-dialog :visible.sync="show"&gt;&lt;/el-dialog&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapState&#125; from 'vuex';export default &#123; computed:&#123; //这里的三点叫做 : 扩展运算符 ...mapState(&#123; show:state=&gt;state.dialog.show &#125;), &#125;&#125;&lt;/script&gt;后两者类似4. VueRouter1234567891011121314151617181920212223242526定义var routes = [ &#123; path:"/one", component:导入的组件1 &#125;, &#123; path:"/two", component:导入的组件2 &#125;,];// 定义路由组件var router = new VueRouter(&#123; routes&#125;);// 定义路由new Vue(&#123; el:"#box", router&#125;); 访问设定的路由后 会将&lt;router-view&gt;&lt;/router-view&gt;替换成相应的模版 html访问方式 &lt;router-link to="/one"&gt;One&lt;/router-link&gt;(类似a标签) js访问方式 this.$router.push('/one'); replace方式 替换当前页面 携带的参数 可以通过this.$route.query.xxxx来获取5. Vue双向绑定原理：利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。缺点：双向数据流是自动管理状态的, 但是在实际应用中会有很多不得不手动处理状态变化的逻辑, 使得程序复杂度上升, 难以调试。6. computed watch methods用法区别：前两者自动追踪数据，执行相关函数，最后一个手动调用；computed是计算属性，用法与data一致watch像事件监听，对象发生变化时，执行相关操作methods与js中执行方法类似computed通常只有get属性数据变化的同时进行异步操作或者是比较大的开销，那watch为最佳选择watch的对象必须事先声明七、算法相关1. 各种排序实现相关数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140// 冒泡排序: 比较两个相邻的项，如果第一个大于第二个则交换他们的位置,元素项向上移动至正确的顺序，就好像气泡往上冒一样冒泡demo:function bubbleSort(arr) &#123; let len = arr.length; for (let i = 0; i &lt; len; i++) &#123; for (let j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比 [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]]; &#125; &#125; &#125; return arr;&#125;// 1) 首先，在数组中选择一个中间项作为主元// 2) 创建两个指针，左边的指向数组第一个项，右边的指向最后一个项，移动左指针，直到找到一个比主元大的项，接着，移动右边的指针，直到找到一个比主元小的项，然后交换它们。重复这个过程，直到// 左侧的指针超过了右侧的指针。这个使比主元小的都在左侧，比主元大的都在右侧。这一步叫划分操作// 3) 接着，算法对划分后的小数组（较主元小的值组成的的小数组， 以及较主元大的值组成的小数组）重复之前的两个步骤，直到排序完成快排demo:function quickSort(arr, left, right) &#123; let len = arr.length; let partitionIndex; left = typeof left !== 'number' ? 0 : left; right = typeof right !== 'number' ? len - 1 : right; if (left &lt; right) &#123; partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); &#125; return arr;&#125;function partition(arr, left, right) &#123; //分区操作 let pivot = left; //设定基准值（pivot） let index = pivot + 1; for (let i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; [arr[i], arr[index]] = [arr[index], arr[i]]; index++; &#125; &#125; [arr[pivot], arr[index - 1]] = [arr[index - 1], arr[pivot]]; return index - 1;&#125;// 选择排序：大概思路是找到最小的放在第一位，找到第二小的放在第二位，以此类推 算法复杂度O(n^2)选择demo:function selectionSort(arr) &#123; let len = arr.length; let minIndex; for (let i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (let j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数 minIndex = j; //将最小数的索引保存 &#125; &#125; [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; &#125;return arr;&#125;// 插入排序：每次排一个数组项，假设数组的第一项已经排序，接着，把第二项与第一项进行对比，第二项是该插入到第一项之前还是之后，第三项是该插入到第一项之前还是第一项之后还是第三项插入demo:function insertionSort(arr) &#123; let len = arr.length; let preIndex, current; for (let i = 1; i &lt; len; i++) &#123; preIndex = i - 1; current = arr[i]; while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex + 1] = arr[preIndex]; preIndex--; &#125; arr[preIndex + 1] = current; &#125; return arr;&#125;// 归并排序：Mozilla Firefox 使用归并排序作为Array.prototype.sort的实现，而chrome使用快速排序的一个变体实现的,前面三种算法性能不好，但归并排序性能不错 算法复杂度O(nlog^n)// 归并排序是一种分治算法。本质上就是把一个原始数组切分成较小的数组，直到每个小数组只有一个位置，接着把小数组归并成较大的数组，在归并过程中也会完成排序，直到最后只有一个排序完毕的大数组归并demo:function mergeSort(arr) &#123; //采用自上而下的递归方法 let len = arr.length; if(len &lt; 2) &#123; return arr; &#125; let middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right)&#123; let result = []; while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; result.push(...left); result.push(...right); return result;&#125;//堆排序：堆排序把数组当中二叉树来排序而得名。// 1）索引0是树的根节点；2）除根节点为，任意节点N的父节点是N/2；3）节点L的左子节点是2*L；4）节点R的右子节点为2*R + 1// 本质上就是先构建二叉树，然后把根节点与最后一个进行交换，然后对剩下对元素进行二叉树构建，进行交换，直到剩下最后一个堆demo:var len; //因为声明的多个函数都需要数据长度，所以把len设置成为全局变量function buildMaxHeap(arr) &#123; //建立大顶堆 len = arr.length; for (let i = Math.floor(len / 2); i &gt;= 0; i--) &#123; heapify(arr, i); &#125;&#125;function heapify(arr, i) &#123; //堆调整 let left = 2 * i + 1; let right = 2 * i + 2; let largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest !== i) &#123; [arr[i], arr[largest]] = [arr[largest], arr[i]]; heapify(arr, largest); &#125;&#125;function heapSort(arr) &#123; buildMaxHeap(arr); for (let i = arr.length - 1; i &gt; 0; i--) &#123; [arr[0],arr[i]]=[arr[i],arr[0]]; len--; heapify(arr, 0); &#125; return arr;&#125;2. 二分查找思路（1）首先，从有序数组的中间的元素开始搜索，如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。（2）如果目标元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。（3）如果某一步数组为空，则表示找不到目标元素。1234567891011121314151617181920212223242526272829303132333435// 非递归算法function binary_search(arr, key) &#123; let low = 0; let high = arr.length - 1; while(low &lt;= high)&#123; let mid = parseInt((high + low) / 2); if(key === arr[mid])&#123; return mid; &#125;else if(key &gt; arr[mid])&#123; low = mid + 1; &#125;else if(key &lt; arr[mid])&#123; high = mid -1; &#125;else&#123; return -1; &#125; &#125;&#125; // 递归算法function binary_search(arr,low, high, key) &#123; if (low &gt; high)&#123; return -1; &#125; let mid = parseInt((high + low) / 2); if(arr[mid] === key)&#123; return mid; &#125;else if (arr[mid] &gt; key)&#123; high = mid - 1; return binary_search(arr, low, high, key); &#125;else if (arr[mid] &lt; key)&#123; low = mid + 1; return binary_search(arr, low, high, key); &#125;&#125;;3. 二叉树相关12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849创建function Node(data,left,right)&#123; this.data = data;//数值 this.left = left;//左节点 this.right = right;//右节点&#125;;插入二叉树function insert(node,data)&#123; //创建一个新的节点 let newNode = new Node(data,null,null); //判断是否存在根节点，没有将新节点存入 if(node == null)&#123; node = newNode; &#125;else&#123; //获取根节点 let current = node; let parent; while(true)&#123; //将当前节点保存为父节点 parent = current; //将小的数据放在左节点 if(data &lt; current.data)&#123; //获取当前节点的左节点 //判断当前节点下的左节点是否有数据 current = current.left; if(current == null)&#123; //如果没有数据将新节点存入当前节点下的左节点 parent.left = newNode; break; &#125; &#125;else&#123; current = current.right; if(current == null)&#123; parent.right = newNode; break; &#125; &#125; &#125; &#125;&#125;翻转二叉树function invertTree(node) &#123; if (node !== null) &#123; node.left, node.right = node.left, node.right; invertTree(node.left); invertTree(node.right); &#125; return node;&#125;查找链表中倒数第k个结点2个思路1：先遍历出长度，然后查找长度-k+1的值2：2个指针，一个指针先走k-1，然后两个一起走到底部，后者就是结果八、网络安全相关1. XSS CSRFXSS(跨站脚本攻击)，恶意的注入html代码，其他用户访问时，会被执行特点：能注入恶意的HTML/JavaScript代码到用户浏览的网页上，从而达到Cookie资料窃取、会话劫持、钓鱼欺骗等攻击防御手段：浏览器禁止页面的JS访问带有HttpOnly属性的Cookie两端进行输入格式检查通过编码转义的方式进行输出检查CSRF(攻击跨站请求伪造)特点：重要操作的所有参数都是可以被攻击者猜测到的。攻击者预测出URL的所有参数与参数值，才能成功地构造一个伪造的请求。防御手段：token验证机制，比如请求数据字段中添加一个token，响应请求时校验其有效性用户操作限制，比如验证码（繁琐，用户体验差）请求来源限制，比如限制HTTP Referer才能完成操作（防御效果相比较差）实践中常用第一种九、webpack相关1. 打包体积 优化思路 打包效率提取第三方库或通过引用外部文件的方式引入第三方库代码压缩插件UglifyJsPlugin服务器启用gzip压缩按需加载资源文件 require.ensure优化devtool中的source-map剥离css文件，单独打包去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致开发环境采用增量构建，启用热更新开发环境不做无意义的工作如提取css计算文件hash等配置devtool选择合适的loader个别loader开启cache 如babel-loader第三方库采用引入方式提取公共代码优化构建时的搜索路径 指明需要构建目录及不需要构建目录模块化引入需要的部分2. Loader编写一个loader123456789101112131415161718loader就是一个node模块，它输出了一个函数。当某种资源需要用这个loader转换时，这个函数会被调用。并且，这个函数可以通过提供给它的this上下文访问Loader API。reverse-txt-loader定义module.exports = function(src) &#123; //src是原文件内容（abcde），下面对内容进行处理，这里是反转 var result = src.split('').reverse().join(''); //返回JavaScript源码，必须是String或者Buffer return `module.exports = '$&#123;result&#125;'`;&#125;使用&#123; test: /\.txt$/, use: [ &#123; './path/reverse-txt-loader' &#125; ]&#125;,3. plugins使用范围更广，通常只需要require()然后添加到plugins数组中，且需要new一个十、其他1. URL到界面显示发生了什么DNS解析先本地缓存找，在一层层找将常见的地址解析成唯一对应的ip地址基本顺序为：本地域名服务器-&gt;根域名服务器-&gt;com顶级域名服务器依次类推下去,找到后记录并缓存下来如www.google.com为. -&gt; .com -&gt; google.com. -&gt; www.google.com.TCP连接三次握手，只要没收到确认消息就要重新发主机向服务器发送一个建立连接的请求（您好，我想认识您）；服务器接到请求后发送同意连接的信号（好的，很高兴认识您）；主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接。发送HTTP请求浏览器会分析这个url，并设置好请求报文发出。请求报文中包括请求行、请求头、空行、请求主体。https默认请求端口443， http默认80。常见的http请求如下:123456789101112POST / HTTP1.1Host:www.wrox.comUser-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)Content-Type:application/x-www-form-urlencodedContent-Length:40Connection: Keep-Alivename=Professional%20Ajax&amp;publisher=Wiley第一部分：请求行，第一行说明是post请求，以及http1.1版本。第二部分：请求头部，第二行至第六行。第三部分：空行，第七行的空行。第四部分：请求数据，第八行。服务器处理请求并返回HTTP报文后端处理返回http报文如下:12345678910111213141516HTTP/1.1 200 OKDate: Fri, 22 May 2009 06:07:21 GMTContent-Type: text/html; charset=UTF-8&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;!--body goes here--&gt; &lt;/body&gt;&lt;/html&gt;第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8第三部分：空行，消息报头后面的空行是必须的第四部分：响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。浏览器解析渲染页面通过HTML解析器解析HTML文档，构建一个DOM Tree，同时通过CSS解析器解析HTML中存在的CSS，构建Style Rules，两者结合形成一个Attachment。通过Attachment构造出一个呈现树（Render Tree）Render Tree构建完毕，进入到布局阶段（layout/reflow），将会为每个阶段分配一个应出现在屏幕上的确切坐标。最后将全部的节点遍历绘制出来后，一个页面就展现出来了。遇到script会停下来执行，所以通常把script放在底部连接结束2. 组件封装目的：为了重用，提高开发效率和代码质量注意：低耦合，单一职责，可复用性，可维护性常用操作：分析布局初步开发化繁为简组件抽象3. JS异步加载动态生成script标签添加h5的async defer属性，前者乱序不适合依赖性加载async 是“下载完就执行”， defer 是“渲染完再执行”4. css与js动画差异css性能好css代码逻辑相对简单js动画控制好js兼容性好js可实现的动画多js可以添加事件5. 负载均衡多台服务器共同协作，不让其中某一台或几台超额工作，发挥服务器的最大作用http重定向负载均衡：调度者根据策略选择服务器以302响应请求，缺点只有第一次有效果，后续操作维持在该服务器dns负载均衡：解析域名时，访问多个ip服务器中的一个（可监控性较弱）反向代理负载均衡：访问统一的服务器，由服务器进行调度访问实际的某个服务器，对统一的服务器要求大，性能受到 服务器群的数量6. CDN内容分发网络，基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。7. 内存泄漏定义：程序中己动态分配的堆内存由于某种原因程序未释放或无法释放引发的各种问题 js中可能出现的内存泄漏情况结果：变慢，崩溃，延迟大等原因：全局变量dom清空时，还存在引用ie中使用闭包定时器未清理子元素存在引起的内存泄露避免策略：减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；注意程序逻辑，避免“死循环”之类的 ；避免创建过多的对象 原则：不用了的东西要及时归还。减少层级过多的引用8. babel原理ES6、7代码输入 -&gt; babylon进行解析 -&gt; 得到AST（抽象语法树）-&gt; plugin用babel-traverse对AST树进行遍历转译 -&gt;得到新的AST树-&gt;用babel-generator通过AST树生成ES5代码、9. promise特性：Promise 对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止，也即是说，错误总会被下一个catch语句捕获10. js自定义事件三要素：document.createEvent()event.initEvent()element.dispatchEvent()1234567891011121314151617181920212223242526272829demo:(en:自定义事件名称，fn:事件处理函数，addEvent:为DOM元素添加自定义事件，triggerEvent:触发自定义事件)window.onload = function()&#123; var demo = document.getElementById("demo"); demo.addEvent("test",function()&#123;console.log("handler1")&#125;); demo.addEvent("test",function()&#123;console.log("handler2")&#125;); demo.onclick = function()&#123; this.triggerEvent("test"); &#125;&#125;Element.prototype.addEvent = function(en,fn)&#123; this.pools = this.pools || &#123;&#125;; if(en in this.pools)&#123; this.pools[en].push(fn); &#125;else&#123; this.pools[en] = []; this.pools[en].push(fn); &#125;&#125;Element.prototype.triggerEvent = function(en)&#123; if(en in this.pools)&#123; var fns = this.pools[en]; for(var i=0,il=fns.length;i&lt;il;i++)&#123; fns[i](); &#125; &#125;else&#123; return; &#125;&#125;11. es6模块 commonjs amd cmdCommonJS 的规范中，每个 JavaScript 文件就是一个独立的模块上下文（module context），在这个上下文中默认创建的属性都是私有的。也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。CommonJS是同步加载模块,在浏览器中会出现堵塞情况，所以不适用AMD 异步，需要定义回调define方式es6 一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量es6还可以导出类、方法，自动适用严格模式12. 前后端路由差别后端每次路由请求都是重新访问服务器前端路由实际上只是JS根据URL来操作DOM元素，根据每个页面需要的去服务端请求数据，返回数据后和模板进行组合。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Vue</tag>
        <tag>面试</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo文章使用 hexo-blog-encrypt 插件加密访问]]></title>
    <url>%2F2019%2F03%2F10%2F4%2F</url>
    <content type="text"><![CDATA[请输入密码阅读全文... Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>加密</tag>
        <tag>Hexo</tag>
        <tag>hexo-blog-encrypt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Valine评论框样式美化]]></title>
    <url>%2F2019%2F02%2F13%2FValine%E8%AF%84%E8%AE%BA%E6%A1%86%E6%A0%B7%E5%BC%8F%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[我感觉我一个强迫症的就不应该搞前端，太吹毛求疵追求完美了，哪里有一点点觉得不漂亮就想改。博客的评论系统用过好几家（虽然都没有人评论比如gitalk，来必力之前用的来必力，加载慢的问题是解决了，但是总觉得登陆的反应也很慢想来想去还是觉得valine好用免登陆，使用方便，直接填了昵称和邮箱就可以评论有回复邮件提醒功能！很好用不过之前没用valine的原因时它评论框样式感觉不好看所以这次我用回valine，首先改了样式修改样式前后对比修改前的默认样式如下图：修改后的样式如下图：好像也没太大变化，不过就是看着顺眼了使用valine这个没什么好说的，next主题在自带的，配置很简单，网上搜一下就有添加样式表在themes\next\source\css\custom目录下的custom.styl文件中添加如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161// Custom styles./*valine 评论系统样式*/div#comments.comments.v&#123; margin-top: 0px !important; margin-left: 0px !important; margin-right: 0px !important;&#125;div.vheader.item2&#123; border-bottom: 1px solid #5f5f5f; height: 35px !important;&#125;.v .vwrap .vheader.item2 .vinput&#123; height: 30px !important; border: 0px !important; width: 25% !important; margin: 0px !important;&#125;input.vnick.vinput&#123; border-right: 2px solid #a4d8fa !important;&#125;div.vcontrol&#123; padding-top: 0px !important;&#125;div#comments.comments.v&#123; border: 0px;&#125;.v .vwrap&#123; border: 2px solid black !important; overflow: visible !important; counter-reset: avater;&#125;.v .vwrap .vedit .vemojis&#123; width: 600px !important; background-color: #fff !important; border-radius: 5px !important;&#125;.v .vwrap .vedit .vpreview &#123; width: 600px !important; background-color: #fff !important; border-radius: 5px !important;&#125;.v .vbtn&#123; background-color: #5f5f5f !important; color: #fff !important;&#125;.v .vwrap .vedit .vctrl&#123; text-align: left !important;&#125;.v .vwrap .vedit .vctrl span&#123; background-color: #7f7f7f !important; color: #fff !important; border-radius: 3px !important; padding: 3px !important;&#125;.v .vwrap .vedit .vctrl&#123; padding: 0px !important; margin: 0px !important;&#125;.v .veditor&#123; min-height: 70px !important; height: 70px !important;&#125;.v .vlist .vquote .vcard&#123; border-left:1px solid #E4E6F1; margin-top:5px;&#125;.v .vlist .vcard .vhead .vsys&#123; display: none !important; background-color: #fff !important;&#125;.v .vlist .vcard .vh .vmeta .vat&#123; background-color: #7f7f7f !important; color: #fff !important; border-radius: 3px !important; padding-left: 10px !important; padding-right: 10px !important;&#125;.v .vlist .vcard .vh .vquote .vmeta&#123; margin-right:50px;&#125;.v .vlist .vcard .vquote&#123; counter-reset: avaters;&#125;.v .vlist .vcard p&#123; margin-bottom: 0px !important; color: #666; text-align: left; letter-spacing: 3px; line-height: 25.59375px;&#125;.v .vlist .vcard .vquote a.at&#123; float: left; margin-right: 13px; color: #567843; text-decoration: none;&#125;.v .vlist .vcard .vquote .vcontent&#123; font-size: 15px; font-weight: 200;&#125;.v .vlist .vcard .vcontent&#123; margin-top: 58px !important; font-size: 15px !important; font-weight: 500 !important; padding-top: 0px !important;&#125;.v .vlist .vcard&#123; padding-top: 8px !important;&#125;.v .vlist .vcard .vhead&#123; float: left !important;&#125;.v .vlist .vcard .vh .vmeta&#123; float: right !important;&#125;.v .vlist .vcard .vcontent.expand:after&#123; content: "点击查看全部" !important; font-weight: 400 !important;&#125;.power&#123; display:none;&#125; .v .vwrap .vedit .vctrl&#123; display:none !important;&#125;/**/更新文件:123hexo cleanhexo d -g然后就ok咯!]]></content>
      <categories>
        <category>Hexo</category>
        <category>Valine</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Valine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS实现最简单的图片懒加载]]></title>
    <url>%2F2019%2F02%2F08%2F%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[一、懒加载什么是懒加载懒加载其实就是延迟加载，是一种对网页性能优化的方式，比如当访问一个页面的时候，优先显示可视区域的图片而不一次性加载所有图片，当需要显示的时候再发送图片请求，避免打开网页时加载过多资源。什么时候用懒加载当页面中需要一次性载入很多图片的时候，往往都是需要用懒加载的。懒加载原理我们都知道HTML中的 &lt;img&gt;标签是代表文档中的一个图像。。说了个废话。。&lt;img&gt;标签有一个属性是 src，用来表示图像的URL，当这个属性的值不为空时，浏览器就会根据这个值发送请求。如果没有 src属性，就不会发送请求。嗯？貌似这点可以利用一下？我先不设置 src，需要的时候再设置？nice，就是这样。我们先不给 &lt;img&gt;设置 src，把图片真正的URL放在另一个属性 data-src中，在需要的时候也就是图片进入可视区域的之前，将URL取出放到 src中。二、实现HTML结构1234567891011121314151617&lt;div class="container"&gt; &lt;div class="img-area"&gt; &lt;img class="my-photo" alt="loading" src="./img/img1.png"&gt; &lt;/div&gt; &lt;div class="img-area"&gt; &lt;img class="my-photo" alt="loading" src="./img/img2.png"&gt; &lt;/div&gt; &lt;div class="img-area"&gt; &lt;img class="my-photo" alt="loading" src="./img/img3.png"&gt; &lt;/div&gt; &lt;div class="img-area"&gt; &lt;img class="my-photo" alt="loading" src="./img/img4.png"&gt; &lt;/div&gt; &lt;div class="img-area"&gt; &lt;img class="my-photo" alt="loading" src="./img/img5.png"&gt; &lt;/div&gt;&lt;/div&gt;仔细观察一下， &lt;img&gt;标签此时是没有 src属性的，只有 alt和 data-src属性。alt 属性是一个必需的属性，它规定在图像无法显示时的替代文本。 data-* 全局属性：构成一类名称为自定义数据属性的属性，可以通过 HTMLElement.dataset来访问。如何判断元素是否在可视区域方法一通过 document.documentElement.clientHeight获取屏幕可视窗口高度通过 document.documentElement.scrollTop获取浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的距离通过 element.offsetTop获取元素相对于文档顶部的距离然后判断②-③&lt;①是否成立，如果成立，元素就在可视区域内。方法二（推荐）通过 getBoundingClientRect()方法来获取元素的大小以及位置，MDN上是这样描述的：The Element.getBoundingClientRect() method returns the size of an element and its position relative to the viewport.这个方法返回一个名为 ClientRect的 DOMRect对象，包含了 top、 right、 botton、 left、 width、 height这些值。MDN上有这样一张图：可以看出返回的元素位置是相对于左上角而言的，而不是边距。我们思考一下，什么情况下图片进入可视区域。假设 constbound=el.getBoundingClientRect();来表示图片到可视区域顶部距离； 并设 constclientHeight=window.innerHeight;来表示可视区域的高度。随着滚动条的向下滚动， bound.top会越来越小，也就是图片到可视区域顶部的距离越来越小，当 bound.top===clientHeight时，图片的上沿应该是位于可视区域下沿的位置的临界点，再滚动一点点，图片就会进入可视区域。也就是说，在 bound.top&lt;=clientHeight时，图片是在可视区域内的。我们这样判断：1234567function isInSight(el)&#123; const bound = el.getBoundingClientRect(); const clientHeight = window.innerHeight; //如果只考虑向下滚动加载 //const clientWidth = window.innerWeight; return bound.top &lt;= clientHeight + 100;&#125;这里有个+100是为了提前加载。加载图片页面打开时需要对所有图片进行检查，是否在可视区域内，如果是就加载。1234567891011121314function checkImgs() &#123; const imgs = document.querySelectorAll('.my-photo'); Array.from(imgs).forEach(el =&gt; &#123; if (isInSight(el))&#123; loadImg(el); &#125; &#125;)&#125;function loadImg(el) &#123; if(!el.src) &#123; const source = el.dataset.src; el.src = source; &#125;&#125;这里应该是有一个优化的地方，设一个标识符标识已经加载图片的index，当滚动条滚动时就不需要遍历所有的图片，只需要遍历未加载的图片即可。函数节流在类似于滚动条滚动等频繁的DOM操作时，总会提到“函数节流、函数去抖”。所谓的函数节流，也就是让一个函数不要执行的太频繁，减少一些过快的调用来节流。基本步骤：获取第一次触发事件的时间戳获取第二次触发事件的时间戳时间差如果大于某个阈值就执行事件，然后重置第一个时间1234567891011121314151617function throttle(fn, mustRun = 500) &#123; const timer = null; let previous = null; return function() &#123; const now = new Date(); const context = this; const args = arguments; if(!previous)&#123; previous = now; &#125; const remaining = now - previous; if (mustRun &amp;&amp; remaining &gt;= mustRun) &#123; fn.apply(context, args); previous = now; &#125; &#125;&#125;这里的 mustRun就是调用函数的时间间隔，无论多么频繁的调用 fn，只有 remaining&gt;=mustRun时 fn才能被执行。三、实验页面打开时可以看出此时仅仅是加载了img1和img2，其它的img都没发送请求，看看此时的浏览器第一张图片是完整的呈现了，第二张图片刚进入可视区域，后面的就看不到了~页面滚动时当我向下滚动，此时浏览器是这样此时第二张图片完全显示了，而第三张图片显示了一点点，这时候我们看看请求情况img3的请求发出来，而后面的请求还是没发出~全部载入时当滚动条滚到最底下时，全部请求都应该是发出的，如图四、更新方法三 IntersectionObserver经大佬提醒，发现了这个方法先附上链接：jjc大大：https://github.com/justjavac/the-front-end-knowledge-you-may-dont-know/issues/10阮一峰大大：http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.htmlAPI Sketch for Intersection Observers：https://github.com/WICG/IntersectionObserverIntersectionObserver可以自动观察元素是否在视口内。1234567var io = new IntersectionObserver(callback, option);// 开始观察io.observe(document.getElementById('example'));// 停止观察io.unobserve(element);// 关闭观察器io.disconnect();callback的参数是一个数组，每个数组都是一个 IntersectionObserverEntry对象，包括以下属性：属性描述time可见性发生变化的时间，单位为毫秒rootBounds与getBoundingClientRect()方法的返回值一样boundingClientRect目标元素的矩形区域的信息intersectionRect目标元素与视口（或根元素）的交叉区域的信息intersectionRatio目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0target被观察的目标元素，是一个 DOM 节点对象我们需要用到 intersectionRatio来判断是否在可视区域内，当 intersectionRatio&gt;0&amp;&amp;intersectionRatio&lt;=1即在可视区域内。代码1234567891011121314151617181920function checkImgs() &#123; const imgs = Array.from(document.querySelectorAll(".my-photo")); imgs.forEach(item =&gt; io.observe(item));&#125;function loadImg(el) &#123; if (!el.src) &#123; const source = el.dataset.src; el.src = source; &#125;&#125;const io = new IntersectionObserver(ioes =&gt; &#123; ioes.forEach(ioe =&gt; &#123; const el = ioe.target; const intersectionRatio = ioe.intersectionRatio; if(intersectionRatio &gt; 0 &amp;&amp; intersectionRatio &lt;=1)&#123; loadImg(el); &#125; el.onload = el.onerror = () =&gt; io.unobserve(el); &#125;);&#125;);]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>图片懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP状态码]]></title>
    <url>%2F2019%2F02%2F04%2FHTTP%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。HTTP状态码的英文为HTTP Status Code。HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：1xx : 信息，服务器收到请求，需要请求者继续执行操作2xx : 成功，操作被成功接收并处理3xx : 重定向，需要进一步的操作以完成请求4xx : 客户端错误，请求包含语法错误或无法完成请求5xx : 服务器错误，服务器在处理请求的过程中发生了错误以下列举了有可能会返回的一系列 HTTP 状态消息：1xx: 信息消息：描述：100 Continue服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。101 Switching Protocols服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。103 Checkpoint用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。2xx: 成功消息：描述：200 OK请求成功（这是对HTTP请求成功的标准应答。）201 Created请求被创建完成，同时新的资源被创建。202 Accepted供处理的请求已被接受，但是处理未完成。203 Non-Authoritative Information请求已经被成功处理，但是一些应答头可能不正确，因为使用的是其他文档的拷贝。204 No Content请求已经被成功处理，但是没有返回新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。205 Reset Content请求已经被成功处理，但是没有返回新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。206 Partial Content客户发送了一个带有Range头的GET请求，服务器完成了它。3xx: 重定向消息：描述：300 Multiple Choices多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。301 Moved Permanently所请求的页面已经转移至新的 URL 。302 Found所请求的页面已经临时转移至新的 URL 。303 See Other所请求的页面可在别的 URL 下被找到。304 Not Modified未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。305 Use Proxy客户请求的文档应该通过Location头所指明的代理服务器提取。306 Switch Proxy目前已不再使用，但是代码依然被保留。307 Temporary Redirect被请求的页面已经临时移至新的 URL 。308 Resume Incomplete用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。4xx: 客户端错误消息：描述：400&nbsp;Bad Request因为语法错误，服务器未能理解请求。401 Unauthorized合法请求，但对被请求页面的访问被禁止。因为被请求的页面需要身份验证，客户端没有提供或者身份验证失败。402 Payment Required此代码尚无法使用。403 Forbidden合法请求，但对被请求页面的访问被禁止。404 Not Found服务器无法找到被请求的页面。405 Method Not Allowed请求中指定的方法不被允许。406 Not Acceptable服务器生成的响应无法被客户端所接受。407 Proxy Authentication Required用户必须首先使用代理服务器进行验证，这样请求才会被处理。408 Request Timeout请求超出了服务器的等待时间。409 Conflict由于冲突，请求无法被完成。410 Gone被请求的页面不可用。411 Length Required“Content-Length” 未被定义。如果无此内容，服务器不会接受请求。412 Precondition Failed请求中的前提条件被服务器评估为失败。413 Request Entity Too Large由于所请求的实体太大，服务器不会接受请求。414 Request-URI Too Long由于 URL 太长，服务器不会接受请求。当 POST 请求被转换为带有很长的查询信息的 GET 请求时，就会发生这种情况。415 Unsupported Media Type由于媒介类型不被支持，服务器不会接受请求。416 Requested Range Not Satisfiable客户端请求部分文档，但是服务器不能提供被请求的部分。417 Expectation Failed服务器不能满足客户在请求中指定的请求头。5xx: 服务器错误消息：描述：500 Internal Server Error请求未完成。服务器遇到不可预知的情况。501 Not Implemented请求未完成。服务器不支持所请求的功能，或者服务器无法完成请求。502 Bad Gateway请求未完成。服务器充当网关或者代理的角色时，从上游服务器收到一个无效的响应。503 Service Unavailable服务器当前不可用（过载或者当机）。504 Gateway Timeout网关超时。服务器充当网关或者代理的角色时，未能从上游服务器收到一个及时的响应。505 HTTP Version Not Supported服务器不支持请求中指明的HTTP协议版本。511 Network Authentication Required用户需要提供身份验证来获取网络访问入口。]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>HTTP状态码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue面试中常问知识点整理]]></title>
    <url>%2F2019%2F02%2F03%2Fvue%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%B8%B8%E9%97%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[看看面试题，只是为了查漏补缺，看看自己那些方面还不懂。切记不要以为背了面试题，就万事大吉了，最好是理解背后的原理，这样面试的时候才能侃侃而谈。不然，稍微有水平的面试官一看就能看出，是否有真才实学还是刚好背中了这道面试题（有空再把例子中代码补上）。一、 对于MVVM的理解？MVVM 是 Model-View-ViewModel 的缩写。Model 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。View 代表UI 组件，它负责将数据模型转化成UI 展现出来。ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。二、 Vue的生命周期beforeCreate（创建前），在数据观测和初始化事件还未开始created（创建后），完成数据观测，属性和方法的运算，初始化事件， $el 属性还没有显示出来beforeMount（载入前），在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。mounted（载入后），在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。beforeUpdate（更新前），在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。updated（更新后），在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。beforeDestroy（销毁前），在实例销毁之前调用。实例仍然完全可用。destroyed（销毁后），在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。1、 什么是vue生命周期？答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。2、 vue生命周期的作用是什么？答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。3、 vue生命周期总共有几个阶段？答：它可以总共分为8个阶段：创建前/后、载入前/后、更新前/后、销毁前/销毁后。4、 第一次页面加载会触发哪几个钩子？答：会触发下面这几个beforeCreate、created、beforeMount、mounted 。5、 DOM 渲染在哪个周期中就已经完成？答：DOM 渲染在 mounted 中就已经完成了。三、 Vue实现数据双向绑定的原理：Object.defineProperty()vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty() 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析[[]] ），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。js实现简单的双向绑定：123456789101112131415161718192021&lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" id="txt"&gt; &lt;p id="show"&gt;&lt;p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; var obj = &#123;&#125; Object.defineProperty(obj, 'txt', &#123; get: function () &#123; return obj &#125;, set: function (newValue) &#123; document.getElementById('txt'.value = newValue document.getElementById('show').innerHTML = newValue &#125; &#125;) document.addEventListener('keyup', function (e) &#123; obj.txt = e.target.value &#125;)&lt;/script&gt;四、 Vue组件间的参数传递1、 父组件与子组件传值父组件传给子组件：子组件通过props方法接受数据；子组件传给父组件：$emit 方法传递参数2、 非父子组件间的数据传递，兄弟组件传值eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适（虽然也有不少人推荐直接用VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道）。五、 Vue的路由实现：hash模式 和 history模式hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用 window.location.hash 读取。特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。history模式：history采用HTML5的新特性；且提供了两个新方法： pushState()， replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。六、 Vue与Angular以及React的区别？版本在不断更新，以下的区别有可能不是很正确。我工作中只用到vue，对angular和react不怎么熟。1、 与AngularJS的区别相同点：都支持指令：内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定；都不支持低端浏览器。不同点：AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观；在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。2、 与React的区别相同点：React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载；在组件开发中都支持mixins的特性。不同点：React采用的Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。七、 vue路由的钩子函数首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。beforeEach主要有3个参数to，from，next。to：route即将进入的目标路由对象。from：route当前导航正要离开的路由。next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。八、 vuex是什么？怎么使用？哪种功能场景使用它？只用来读取的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。在main.js引入store，注入。新建了一个目录store，… export 。场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车state：Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。mutations：mutations定义的方法动态修改Vuex 的 store 中的状态或数据。getters：类似vue的计算属性，主要用来过滤一些数据。action：actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。12345678910111213141516const store = new Vuex.Store(&#123; //store实例 state: &#123; count: 0 &#125;, mutations:&#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit('increment') &#125; &#125;&#125;)modules：项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters，使得结构非常清晰，方便管理。1234567891011121314151617const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules:&#123; a: moduleA, b: moduleB&#125;)九、其它小知识点1、 css只在当前组件起作用答：在style标签中写入scoped即可 例如： &lt;stylescoped&gt;&lt;/style&gt;2、 v-if 和 v-show 区别答：v-if按照条件是否渲染，v-show是display的block或none；3、 $route和$router的区别答：$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。而$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。PS：缺少的案例代码，这几天再补上去。有些地方可能描述的不够清楚，如果有歧义，可能是我理解错了。]]></content>
      <categories>
        <category>Vue</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GET和POST的区别]]></title>
    <url>%2F2019%2F02%2F01%2FGET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[都9102年了，还问GET和POST的区别?1. 前言最近看了一些同学的面经，发现无论什么技术岗位，还是会问到 get 和 post 的区别，而搜索出来的答案并不能让我们装得一手好逼，那就让我们从 HTTP 报文的角度来撸一波，从而搞明白他们的区别。2. 标准答案在开撸之前吗，让我们先看一下标准答案长什么样子 w3school: GET 对比 POST。标准答案很美好，但是在面试的时候把下面的表格甩面试官一脸，估计会装逼不成反被*。注意，并不是说标准答案有误，上述区别在大部分浏览器上是存在的，因为这些浏览器实现了 HTTP 标准。但是，前面列举的只是浏览器实现上的区别，而不是 get 和 post 的本质区别。3. GET 和 POST 报文上的区别先下结论，GET 和 POST 方法没有实质区别，只是报文格式不同。GET 和 POST 只是 HTTP 协议中两种请求方式，而 HTTP 协议是基于 TCP/IP 的应用层协议，无论 GET 还是 POST，用的都是同一个传输层协议，所以在传输上，没有区别。报文格式上，不带参数时，最大区别就是第一行方法名不同POST方法请求报文第一行是这样的 POST /uri HTTP/1.1 \r\nGET方法请求报文第一行是这样的 GET /uri HTTP/1.1 \r\n是的，不带参数时他们的区别就仅仅是报文的前几个字符不同而已带参数时报文的区别呢？ 在约定中，GET 方法的参数应该放在 url 中，POST 方法参数应该放在 body 中举个例子，如果参数是 name=chengqm, age=22。GET 方法简约版报文是这样的:12GET /index.php?name=qiming.c&amp;age=22 HTTP/1.1Host: localhostPOST 方法简约版报文是这样的:1234POST /index.php HTTP/1.1Host: localhostContent-Type: application/x-www-form-urlencodedname=qiming.c&amp;age=22现在我们知道了两种方法本质上是 TCP 连接，没有差别，也就是说，如果我不按规范来也是可以的。我们可以在 URL 上写参数，然后方法使用 POST；也可以在 Body 写参数，然后方法使用 GET。当然，这需要服务端支持。4. 常见问题GET 方法参数写法是固定的吗？在约定中，我们的参数是写在 ? 后面，用 &amp; 分割。我们知道，解析报文的过程是通过获取 TCP 数据，用正则等工具从数据中获取 Header 和 Body，从而提取参数。也就是说，我们可以自己约定参数的写法，只要服务端能够解释出来就行，一种比较流行的写法是 http://www.example.com/user/name/chengqm/age/22。POST 方法比 GET 方法安全？按照网上大部分文章的解释，POST 比 GET 安全，因为数据在地址栏上不可见。然而，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。要想安全传输，就只有加密，也就是 HTTPS。GET 方法的长度限制是怎么回事？在网上看到很多关于两者区别的文章都有这一条，提到浏览器地址栏输入的参数是有限的。首先说明一点，HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。浏览器原因就不说了，服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。POST 方法会产生两个TCP数据包？有些文章中提到，post 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。5. talk is cheap show me the code如果对 get 和 post 报文区别有疑惑，直接起一个 Socket 服务端，然后封装简单的 HTTP 处理方法，直接观察和处理 HTTP 报文，就能一目了然123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/env python# -*- coding: utf-8 -*-import socketHOST, PORT = '', 23333def server_run():listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)listen_socket.bind((HOST, PORT))listen_socket.listen(1) print('Serving HTTP on port %s ...' %PORT)while True: # 接受连接 client_connection, client_address = listen_socket.accept() handle_request(client_connection)def handle_request(client_connection): # 获取请求报文 request = '' while True: recv_data = client_connection.recv(2400) recv_data = recv_data.decode() request += recv_data if len(recv_data) &lt; 2400: break # 解析首行 first_line_array = request.split('\r\n')[0].split(' ') # 分离 header 和 body space_line_index = request.index('\r\n\r\n') header = request[0: space_line_index] body = request[space_line_index + 4:] # 打印请求报文 print(request)# 返回报文 http_response = b"""\HTTP/1.1 200 OK&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello, World!&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p style="color: green"&gt;Hello, World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;""" client_connection.sendall(http_response) client_connection.close()if __name__ == '__main__': server_run()上面代码就是简单的打印请求报文然后返回 HelloWorld 的 html 页面，我们运行起来12[root@chengqm shell]# python httpserver.py Serving HTTP on port 23333 ...然后从浏览器中请求看看打印出来的报文然后就可以手动证明上述说法，比如说要测试 header 和 body 是否分开传输，由于代码没有返回 100 状态码，如果我们 post 请求成功就说明是一起传输的(Chrome/postman)。又比如 w3school 里面说 URL 的最大长度是 2048 个字符，那我们在代码里面加上一句计算 uri 长度的代码12345...# 解析首行first_line_array = request.split('\r\n')[0].split(' ')print('uri长度: %s' % len(first_line_array[1]))...我们用 postman 直接发送超过 2048 个字符的请求看看然后我们可以得出结论，url 长度限制是某些浏览器和服务器的限制，和 HTTP 协议没有关系。到此，我们可以愉快地装逼了 :)END]]></content>
      <categories>
        <category>Get</category>
        <category>Post</category>
      </categories>
      <tags>
        <tag>Get</tag>
        <tag>Post</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[九种跨域方式实现原理]]></title>
    <url>%2F2019%2F01%2F30%2F%E4%B9%9D%E7%A7%8D%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[前 言前后端数据交互经常会碰到请求跨域，什么是跨域，以及有哪几种跨域方式，这是本文要探讨的内容。本文完整的源代码请猛戳github 博客一、什么是跨域？1. 什么是同源策略及其限制内容？同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。同源策略限制内容有：Cookie、LocalStorage、IndexedDB 等存储性内容DOM 节点AJAX 请求发送后，结果被浏览器拦截了但是有三个标签是允许跨域加载资源：123&lt;img src=XXX&gt;&lt;link href=XXX&gt;&lt;script src=XXX&gt;2.常见跨域场景当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示：特别说明两点：第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。第二：在跨域问题上，仅仅是通过“URL 的首部”来识别而不会根据域名对应的 IP 地址是否相同来判断。“URL 的首部”可以理解为“协议, 域名和端口必须匹配”。这里你或许有个疑问：请求跨域了，那么请求到底发出去没有？跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。二、跨域解决方案1.jsonp1) JSONP 原理利用 script 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP 请求一定需要对方的服务器做支持才可以。2) JSONP 和 AJAX 对比JSONP 和 AJAX 相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但 AJAX 属于同源策略，JSONP 属于非同源策略（跨域请求）3) JSONP 优缺点JSONP 优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持 get 方法具有局限性,不安全可能会遭受 XSS 攻击。4) JSONP 的实现流程声明一个回调函数，其函数名(如 show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的 data)。创建一个script标签，把那个跨域的 API 数据接口地址，赋值给 script 的 src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是 show，它准备好的数据是show(‘我不爱你’)。最后服务器把准备的数据通过 HTTP 协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP 函数。123456789101112131415161718192021222324// index.htmlfunction jsonp(&#123; url, params, callback &#125;) &#123; return new Promise((resolve, reject) =&#123; let script = document.createElement('script') window[callback] = function(data) &#123; resolve(data) document.body.removeChild(script) &#125; params = &#123; ...params, callback &#125; // wd=b&amp;callback=show let arrs = [] for (let key in params) &#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`) &#125; script.src = `$&#123;url&#125;?$&#123;arrs.join('&amp;')&#125;` document.body.appendChild(script) &#125;)&#125;jsonp(&#123; url: 'http://localhost:3000/say', params: &#123; wd: 'Iloveyou' &#125;, callback: 'show'&#125;).then(data =&#123; console.log(data)&#125;)上面这段代码相当于向http://localhost:3000/say?wd=Iloveyou&amp;callback=show这个地址请求数据，然后后台返回show(&#39;我不爱你&#39;)，最后会运行 show()这个函数，打印出’我不爱你’12345678910 // server.jslet express = require('express')let app = express()app.get('/say', function(req, res) &#123; let &#123; wd, callback &#125; = req.query console.log(wd) // Iloveyou console.log(callback) // show res.end(`$&#123;callback&#125;('我不爱你')`)&#125;)app.listen(3000)5) jQuery 的 jsonp 形式JSONP 都是 GET 和异步请求的，不存在其他的请求方式和同步请求，且 jQuery 默认就会给 JSONP 的请求清除缓存。12345678910 $.ajax(&#123; url:"http://crossdomain.com/jsonServerResponse", dataType:"jsonp", type:"get",//可以省略 jsonpCallback:"show",//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略 jsonp:"callback",//-&gt;把传递函数名的那个形参callback，可省略 success:function (data)&#123; console.log(data); &#125;&#125;);2.corsCORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。1) 简单请求只要同时满足以下两大条件，就属于简单请求条件 1：使用下列方法之一：GETHEADPOST条件 2：Content-Type 的值仅限于下列三者之一：text/plainmultipart/form-dataapplication/x-www-form-urlencoded请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。2) 复杂请求不符合以上条件的请求就肯定是复杂请求了。复杂请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。我们用PUT向后台请求时，属于复杂请求，后台需做如下配置：12345678910111213 // 允许哪个方法访问我res.setHeader('Access-Control-Allow-Methods', 'PUT')// 预检的存活时间res.setHeader('Access-Control-Max-Age', 6)// OPTIONS请求不做任何处理if (req.method === 'OPTIONS') &#123; res.end()&#125;// 定义后台返回的内容app.put('/getData', function(req, res) &#123; console.log(req.headers) res.end('我不爱你')&#125;)接下来我们看下一个完整复杂请求的例子，并且介绍下 CORS 请求相关的字段123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// index.htmllet xhr = new XMLHttpRequest()document.cookie = 'name=xiamen' // cookie不能跨域xhr.withCredentials = true // 前端设置是否带cookiexhr.open('PUT', 'http://localhost:4000/getData', true)xhr.setRequestHeader('name', 'xiamen')xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; console.log(xhr.response) //得到响应头，后台需设置Access-Control-Expose-Headers console.log(xhr.getResponseHeader('name')) &#125; &#125;&#125;xhr.send()//server1.jslet express = require('express');let app = express();app.use(express.static(__dirname));app.listen(3000);//server2.jslet express = require('express')let app = express()let whitList = ['http://localhost:3000'] //设置白名单app.use(function(req, res, next) &#123; let origin = req.headers.origin if (whitList.includes(origin)) &#123; // 设置哪个源可以访问我 res.setHeader('Access-Control-Allow-Origin', origin) // 允许携带哪个头访问我 res.setHeader('Access-Control-Allow-Headers', 'name') // 允许哪个方法访问我 res.setHeader('Access-Control-Allow-Methods', 'PUT') // 允许携带cookie res.setHeader('Access-Control-Allow-Credentials', true) // 预检的存活时间 res.setHeader('Access-Control-Max-Age', 6) // 允许返回的头 res.setHeader('Access-Control-Expose-Headers', 'name') if (req.method === 'OPTIONS') &#123; res.end() // OPTIONS请求不做任何处理 &#125; &#125; next()&#125;)app.put('/getData', function(req, res) &#123; console.log(req.headers) res.setHeader('name', 'jw') //返回一个响应头，后台需设置 res.end('我不爱你')&#125;)app.get('/getData', function(req, res) &#123; console.log(req.headers) res.end('我不爱你')&#125;)app.use(express.static(__dirname))app.listen(4000)上述代码由http://localhost:3000/index.html向http://localhost:4000/跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。3.postMessagepostMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一，它可用于解决以下方面的问题：页面和其打开的新窗口的数据传递多窗口之间消息传递页面与嵌套的 iframe 消息传递上面三个场景的跨域数据传递postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。otherWindow.postMessage(message, targetOrigin, [transfer]);message: 将要发送到其他 window 的数据。targetOrigin:通过窗口的 origin 属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个 URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配 targetOrigin 提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。transfer(可选)：是一串和 message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。接下来我们看个例子： http://localhost:3000/a.html页面向http://localhost:4000/b.html传递“我爱你”,然后后者传回”我不爱你”。123456789101112// a.html&lt;iframe src="http://localhost:4000/b.html" frameborder="0" id="frame" onload="load()"&gt;&lt;/iframe//等它加载完触发一个事件//内嵌在http://localhost:3000/a.html&lt;script&gt; function load() &#123; let frame = document.getElementById('frame') frame.contentWindow.postMessage('我爱你', 'http://localhost:4000') //发送数据 window.onmessage = function(e) &#123; //接受返回数据 console.log(e.data) //我不爱你 &#125;&#125;&lt;/script&gt;12345// b.html window.onmessage = function(e) &#123; console.log(e.data) //我爱你 e.source.postMessage('我不爱你', e.origin) &#125;4.websocketWebsocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket 和 HTTP 都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。原生 WebSocket API 使用起来不太方便，我们使用Socket.io，它很好地封装了 webSocket 接口，提供了更简单、灵活的接口，也对不支持 webSocket 的浏览器提供了向下兼容。我们先来看个例子：本地文件 socket.html 向localhost:3000发生数据和接受数据123456789101112131415161718192021// socket.html&lt;script&gt; let socket = new WebSocket('ws://localhost:3000'); socket.onopen = function () &#123; socket.send('我爱你');//向服务器发送数据 &#125; socket.onmessage = function (e) &#123; console.log(e.data);//接收服务器返回的数据 &#125;&lt;/script&gt;// server.jslet express = require('express');let app = express();let WebSocket = require('ws');//记得安装wslet wss = new WebSocket.Server(&#123;port:3000&#125;);wss.on('connection',function(ws) &#123; ws.on('message', function (data) &#123; console.log(data); ws.send('我不爱你') &#125;);&#125;)5. Node 中间件代理(两次跨域)实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。代理服务器，需要做以下几个步骤：接受客户端请求 。将请求 转发给服务器。拿到服务器 响应 数据。将 响应 转发给客户端。我们先来看个例子：本地文件 index.html 文件，通过代理服务器http://localhost:3000向目标服务器http://localhost:4000请求数据。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// index.html(http://127.0.0.1:5500) &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; $.ajax(&#123; url: 'http://localhost:3000', type: 'post', data: &#123; name: 'xiamen', password: '123456' &#125;, contentType: 'application/json;charset=utf-8', success: function(result) &#123; console.log(result) // &#123;"title":"fontend","password":"123456"&#125; &#125;, error: function(msg) &#123; console.log(msg) &#125; &#125;) &lt;/script&gt;// server1.js 代理服务器(http://localhost:3000)const http = require('http')// 第一步：接受客户端请求const server = http.createServer((request, response) =&#123; // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段 response.writeHead(200, &#123; 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Methods': '*', 'Access-Control-Allow-Headers': 'Content-Type' &#125;) // 第二步：将请求转发给服务器 const proxyRequest = http .request( &#123; host: '127.0.0.1', port: 4000, url: '/', method: request.method, headers: request.headers &#125;, serverResponse =&#123; // 第三步：收到服务器的响应 var body = '' serverResponse.on('data', chunk =&#123; body += chunk &#125;) serverResponse.on('end', () =&#123; console.log('The data is ' + body) // 第四步：将响应结果转发给浏览器 response.end(body) &#125;) &#125; ) .end()&#125;)server.listen(3000, () =&#123; console.log('The proxyServer is running at http://localhost:3000')&#125;)// server2.js(http://localhost:4000)const http = require('http')const data = &#123; title: 'fontend', password: '123456' &#125;const server = http.createServer((request, response) =&#123; if (request.url === '/') &#123; response.end(JSON.stringify(data)) &#125;&#125;)server.listen(4000, () =&#123; console.log('The server is running at http://localhost:4000')&#125;)上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在 index.html 文件打印出{&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;}6.nginx 反向代理实现原理类似于 Node 中间件代理，需要你搭建一个中转 nginx 服务器，用于转发请求。使用 nginx 反向代理实现跨域，是最简单的跨域方式。只需要修改 nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器性能。实现思路：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。先下载nginx，然后将 nginx 目录下的 nginx.conf 修改如下:1234567891011121314// proxy服务器server &#123; listen 80; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125;最后通过命令行nginx -s reload启动 nginx12345678910111213141516171819202122// index.htmlvar xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);xhr.send();// server.jsvar http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, &#123; 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...');7.window.name + iframewindow.name 属性的独特之处：name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。其中 a.html 和 b.html 是同域的，都是http://localhost:3000;而 c.html 是http://localhost:40001234567891011121314151617// a.html(http://localhost:3000/b.html)&lt;iframe src="http://localhost:4000/c.html" frameborder="0" onload="load()" id="iframe"&gt;&lt;/iframe&gt;&lt;script&gt; let first = true // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name function load() &#123; if(first)&#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 let iframe = document.getElementById('iframe'); iframe.src = 'http://localhost:3000/b.html'; first = false; &#125;else&#123; // 第2次onload(同域b.html页)成功后，读取同域window.name中数据 console.log(iframe.contentWindow.name); &#125; &#125;&lt;/script&gt;b.html 为中间代理页，与 a.html 同域，内容为空。1234// c.html(http://localhost:4000/c.html) &lt;script&gt; window.name = '我不爱你' &lt;/script&gt;总结：通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。8.location.hash + iframe实现原理： a.html 欲与 c.html 跨域相互通信，通过中间页 b.html 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js 访问来通信。具体实现步骤：一开始 a.html 给 c.html 传一个 hash 值，然后 c.html 收到 hash 值后，再把 hash 值传递给 b.html，最后 b.html 将结果放到 a.html 的 hash 值中。同样的，a.html 和 b.html 是同域的，都是http://localhost:3000;而 c.html 是http://localhost:40001234567891011121314151617// a.html &lt;iframe src="http://localhost:4000/c.html#iloveyou"&gt;&lt;/iframe&gt; &lt;script&gt; window.onhashchange = function () &#123; //检测hash的变化 console.log(location.hash); &#125; &lt;/script&gt;// b.html &lt;script&gt; window.parent.parent.location.hash = location.hash //b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面 &lt;/script&gt;// c.htmlconsole.log(location.hash); let iframe = document.createElement('iframe'); iframe.src = 'http://localhost:3000/b.html#idontloveyou'; document.body.appendChild(iframe);9.document.domain + iframe该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。只需要给页面添加 document.domain =&#39;test.com&#39; 表示二级域名都相同就可以实现跨域。实现原理：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。我们看个例子：页面a.zf1.cn:3000/a.html获取页面b.zf1.cn:3000/b.html中 a 的值12345678910111213141516171819// a.html&lt;body&gt; helloa &lt;iframe src="http://b.zf1.cn:3000/b.html" frameborder="0" onload="load()" id="frame"&gt;&lt;/iframe&gt; &lt;script&gt; document.domain = 'zf1.cn' function load() &#123; console.log(frame.contentWindow.a); &#125; &lt;/script&gt;&lt;/body&gt;// b.html&lt;body&gt; hellob &lt;script&gt; document.domain = 'zf1.cn' var a = 100; &lt;/script&gt;&lt;/body&gt;三、总 结CORS 支持所有类型的 HTTP 请求，是跨域 HTTP 请求的根本解决方案JSONP 只支持 GET 请求，JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。不管是 Node 中间件代理还是 nginx 反向代理，主要是通过同源策略对服务器不加限制。日常工作中，用得比较多的跨域方案是 cors 和 nginx 反向代理参考文章跨域资源共享 CORS 详解前端面试之道window.postMessage前端常见跨域解决方案（全）深入跨域问题(4) - 利用代理解决跨域]]></content>
      <categories>
        <category>跨域</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>跨域</tag>
        <tag>jsonp</tag>
        <tag>cors</tag>
        <tag>postMessage</tag>
        <tag>websocket</tag>
        <tag>Node中间件代理</tag>
        <tag>nginx反向代理</tag>
        <tag>window.name + iframe</tag>
        <tag>location.hash + iframe</tag>
        <tag>document.domain + iframe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数字和字符串之间相互转化的纠纷]]></title>
    <url>%2F2019%2F01%2F23%2F5%2F</url>
    <content type="text"><![CDATA[JS数字和字符串之间相互转化的纠纷一、字符串转数字1. parseInt() 函数parseInt() 函数从string的开始解析，返回一个整数parseInt(‘123’) : 返回 123；parseInt(‘1234xxx’) : 返回 1234；parseInt(‘123.456’) : 返回 123；parseInt(‘1 2 3’) : 返回 1；字符串的情况，自会返回第一个数parseInt(‘bb cc 12’) : 返回 NaN；字符串第一个不是数，返回nanparseInt(‘123’ 321) : 返回 321；parseInt(“AF”, 16); 返回 175；会自动把二进制十六进制八进制的转化成数字如果解析不到数字，则将返回一个NaN的值，可以用isNaN()函数来检测；parseFloat()只会返回小数2. 字符前加“+”var n =+”123”:返回 1233. 字符加“*”var n =”123”*1:返回 1234. 字符串数组分割增加var arr = str.split(“,”) 一个字符串组，用，都分割成多个b = a.join(“-“);-是指定的分割符，可以随意，将数组转化成一个字符串5. 字符串和数字相加返回字符串console.log(12+”12”):返回”1212”console.log(‘12’ + ‘34’)返回’1234’console.log(‘12’ + 34 ) 返回’1234’console.log(12 + ‘34’’）返回1234’console.log(12 + 34 ) 返回466. 当字符串和多个数字相加，用括号扩起来(&quot;&lt;img src=&#39;images/&quot; + 2 + 1 + &quot;.jpg&#39;&gt;&quot;) 返回(&quot;&lt;img src=&#39;images/&quot; + 21 + &quot;.jpg&#39;&gt;&quot;)如果想转成3(&quot;&lt;img src=&#39;images/&quot; + （2+1）+ &quot;.jpg&#39;&gt;&quot;) 返回(&quot;&lt;img src=&#39;images/&quot; + 3 + &quot;.jpg&#39;&gt;&quot;)如果前面是数字相加，则可以先把数字加起来var a = 10 + 20 + ‘abc’ + ‘cd’; 返回a的值为:30abccd7. eval（）如果想进行字符串的运算eval(“x=10;y=20;document.write(x*y)”) 返回200document.write(eval(“2+2”)) 返回4var x=10document.write(eval(x+17） 返回27二、数字转字符串1. tostring（）n = 100x = n.toString() =&gt; “100”或是（100）toString() //tostring（2/16/8）还可以实现进制的转化2. 数字+任意字符串“”var n = 1234;var nn = 1234+””关于字符串判断字符串是否包含 包含返回下标 不包含返回-1var i = str.indexOf(“x”)最后一次下标的字符串的字符串var i = str .lastIndexOf(“”)转化大小写str.toUpperCase() 转大写str.tolowerCase() 转小写截取字符串 字符串.substr（”从哪开始”,”截取几个”）str.substr(0,5)]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo文章简单加密访问]]></title>
    <url>%2F2019%2F01%2F21%2F0%2F</url>
    <content type="text"><![CDATA[即使是最简单的密码功能也足以阻止90%的访问者.一、前言一开始使用Hexo的时候，是喜欢它的简单：因为可以直接编译成纯静态文件，方便部署。可是在使用过程中，又发现诸多不便：也因为它全是纯静态页面。突发奇想，能不能给文章加上一个加密访问的功能……在经过实践之后，运用到自己博客中，发现有不少的访客对这个功能甚是感兴趣，所以也就在这里找个时间写写自己加密的小诀窍吧算是。二、原理由于 Hexo 最终编译出来的文件是纯静态的，也就意味着文章的所有信息其实还是原封不动展示在页面中的，当你输入一篇文章的网址，所有的内容就已经跟随网络传输过来了。那我博客使用的加密是怎么实现的呢？这就要讲到 js 的阻塞机制了，在以往的经验中，当页面中有调用alert();函数的时候，整个页面会停止运行，直到你点击确定之后，页面的中的代码才会继续执行下去。我们这里需要的也是这样一个假象，阻止整个页面的渲染，直到你输入了正确的密码才能让页面继续渲染实际的文章。可是alert只有提醒的功能，没有输入的功能，所以这里要用到的是promt函数。例子参见如下：12var password = promt('请输入文章密码');alert(password);三、实现究竟要把上述代码加在哪里呢？找到themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件。按道理是添加在任何地方都行，但是推荐加在所有的&lt;meta&gt;标签之后，个人建议，仅做参考。以下是我加的代码：12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码','') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt;之后，在你想要加密的文章的头文件里添加上password: 123456（ps：123456是你想设置的密码）即可。注意，这里仅针对Hexo平台的next主题。但是，它的代码和思想是通用的，你在Hexo的其他主题，甚至是Jekyll的主题里也是可以做到的，只是要摆放的位置会不一样。如果你好奇page.password是什么东西，那么恭喜你，你对 Hexo 的结构还是很熟悉的。page这个变量就是你在hexo new的时候生成文件中最顶部的东西，以下我给出这篇文章的头部参考：12345678910---title: Hexo文章简单加密访问date: 2019-01-21 16:09:45tags: - 加密 - Hexocategories: - Hexopassword: 123456---这样我们就好像使用静态页面完成了部分只有动态页面能完成的东西。四、总结本来只是简单的纯静态页面，但是经历不断的更新和改进，便有了静态页面统计访问量的工具；有了静态页面添加评论的工具；甚至有了静态页面进行搜索的功能等等。个人想出来的静态页面加密功能根本算不上技术上的创新，只能说是一点小技巧的应用吧，小技巧也能迷惑住大家的眼睛，也算是喜事一件。五、后记已将博客加密功能改成使用 hexo-blog-encrypt 插件加密，最新密码功能查看效果，具体请参见我的博客文档附上传送门：https://chen-95.gitee.io/2019/01/25/4/]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>加密</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[野狗云帐号分享]]></title>
    <url>%2F2019%2F01%2F21%2F%E9%87%8E%E7%8B%97%E4%BA%91%E5%B8%90%E5%8F%B7%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[请输入密码获取野狗云帐号... Incorrect Password! No content to display! U2FsdGVkX19FXdaUnlgGZBftvuXFkkAF/pSyZ1Thgz4hAck46pdfu3ZosYPHCsw9n2fe9K++lPPv7exhbeLkRd4vIJsP68WV+O7RqgWD14iMgInDHwQKVx6+boNXo007yZ3sohJnsIw/OMnS81JR5s80BT6gVxy1S5ufMZPTRklFOSkrbOyoAR63Mv0vnXRa3CaZA7Z3M2OgF4uGAljqPYZcgum7VrMKp7jt/Y6UHSKFhnF3AigvD+JENrtdLJoZCc/9MX31A9/3kR02UrkruVYnP+RkMhpzDDFh7wR11j/OSKPCjcQLF1mzKjLiZaFjMkOYdLY9KMpPYBUBcT10YxLilfpucinYpeeOCQCYef8EG0SmlmhQNd9j4EAMXXePf0FbqP+SiqbzmphFOSW1ZkRRsY/mtHSanaw9xHaJbBS4a/UoZgbElg5HXpKGU4BMDHw320B4LnJ1ZXclfq7Z2lEFlZ73MYUBcVRWv/fCVUvxgkOETSIbago1NBM2HzjNXLneLpTubO/ZcGtIsC7zZg2VSv3CoElaKbZf4FSVLikITfL5jkXcfeEX7hBcDgpVFekg2hZdl1wSHQdwTf49sxTdd+8H2TeY4C3k2xHqI72sAPe83t3DqirkZuNZy2DAwtn3MdFBSjZO4SDes5eFTxwNdw7rdaobu5qr0aRx8HzLglnJeilLnvm3L8jLToNN2SRaDvMyc5PxLxhQcnLE0YYnHJWpFMhLVSjU/ADdGTYL1vI8DfwcqPbt1uc3IWMhyCYbrRURfyHTzRH8izadaN7h8cDdXqlcQrvgikOQTGbMompJMNOcwVs2XXVbUFG27vfNHsX8pnYpvZiXpNGlqQFtZHWpqH3vjNJKOPuMUC80CU4Zgpe2fY2iUC4/T2v+N5SkOWITGhaQqc4AhCllytlweJ/WorVJIxuIyFAexL634Ar4mKuvSocy9uRHfhMe7+P877MPP4KzFdO2T6n6OVInMj7jakppeOLyqY80K1dlsu7iHJ4KJcduRPhvJ/w9l9b5xDa21MultnLZizhUFtEvXfybPc+jrJzfedEXqVIzv6kdC1mRH0YPZuPjT0u1HqZiei2uoIlKaDQ+V4w+veuiTVqU9O/RyuHHry0pHgDZLaRkWNT1xrPfuVH3x2prExg5VP09zeqjh1qvnic8/wxkhHi5Ki17OC2jjjkPK9k=]]></content>
      <categories>
        <category>野狗云</category>
      </categories>
      <tags>
        <tag>野狗云</tag>
        <tag>帐号</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT主题添加点击爱心效果]]></title>
    <url>%2F2019%2F01%2F12%2F3%2F</url>
    <content type="text"><![CDATA[1.创建js文件在/themes/next/source/js/src下新建文件 clicklove.js ，接着把该链接下的代码拷贝粘贴到 clicklove.js 文件中。代码如下：1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);2.修改_layout.swig在\themes\next\layout\_layout.swig文件末尾添加：12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/clicklove.js"&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>Javascript</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>点击效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS实现向右导航icon]]></title>
    <url>%2F2019%2F01%2F08%2FCSS%E5%AE%9E%E7%8E%B0%E5%90%91%E5%8F%B3%E5%AF%BC%E8%88%AAicon%2F</url>
    <content type="text"><![CDATA[对于看过CSS绘制三角形的童鞋来说，实现向右导航 icon 很好理解，可能大家稍加即可知晓实现方式。是的，只需要设置一个元素的相邻 border，之后旋转一下即可。HTML1&lt;span id="right-arrow"&gt;&lt;/span&gt;CSS12345678#right-arrow &#123; display: inline-block; width: 17px; height: 17px; border-top: 2px solid red; border-right: 2px solid red; transform: rotate(45deg);&#125;解析给 span 元素设置合适的宽高，到达要求的效果大小设置元素的两个相邻 border，宽度合适即可将元素旋转 45 度即为向右导航 icon 效果border 的颜色为 icon 的颜色运行效果]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>icon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 实现关闭 icon]]></title>
    <url>%2F2019%2F01%2F08%2FCSS%E5%AE%9E%E7%8E%B0%E5%85%B3%E9%97%ADicon%2F</url>
    <content type="text"><![CDATA[本文介绍关闭 icon 的实现。关闭 icon 有两条线组成，所以很简单的设想就是两条横线，分别旋转不同角度即可。HTML1&lt;span id="close"&gt;&lt;/span&gt;CSS123456789101112131415#close &#123; display: inline-block; width: 23px; height: 2px; background: red; transform: rotate(45deg);&#125;#close::after &#123; content: ''; display: block; width: 23px; height: 2px; background: red; transform: rotate(-90deg);&#125;解析给 span 元素设置合适的宽高，到达要求的效果大小旋转 span 元素，实现一条线的效果添加 ::after 伪元素，设置和 span 相同的宽高（注意此处 display 值应为 block，否则设置宽高无效）旋转 ::after 伪元素。由于基准元素 span 已经旋转，伪元素旋转参考点不是水平坐标系，而是旋转后的 span 元素，将伪元素旋转 90 度或 -90 度均可其中设置的背景色即为 icon 的颜色运行效果]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>icon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匿名函数、嵌套函数、闭包是怎么回事？]]></title>
    <url>%2F2019%2F01%2F08%2F2%2F</url>
    <content type="text"><![CDATA[匿名函数： 指的是 没有函数名的函数function (){ console.log(&#39;匿名函数&#39;) }嵌套函数呢 ？ 请看代码：12345678function test ()&#123; var sum = 20; //内嵌函数 demo = function()&#123; alert(sum); console.log('我是嵌套函数'); &#125;&#125;如代码所示，函数内部嵌入函数，称之为嵌套函数。那闭包又是什么呢？不多说，看代码1234567891011function demo()&#123; var num = 0; // 返回一个函数 return function()&#123; alert( num+1 ); &#125; &#125;//将返回的函数赋值给 add 变量var add = demo();// add就是一个闭包add();这么看，感觉像是，只要是嵌套函数，且能访问上一层作用域的变量就是闭包。 是这样吗？我们知道，js中，分为全局作用域，局部作用域，每个函数也就相等于一个局部作用域。同理，变量，也分为全局变量和局部变量。 有什么区别呢？在浏览器中，全局作用域对象是 window，也就是说页面一打开，window对象就存在。在js中，每个函数是局部作用域，局部变量会随着 函数的执行创建和执行完毕后销毁。而全局变量，只要页面不关闭，则会一直存在。并不会随着函数的执行完毕而销毁。那么和闭包有什么关系呢？在 “javaScript高级程序” 这本书有讲到过“作用域链”的概念, 特殊之处，在于函数内部可以直接读取全局变量。而函数外部却不能读取函数内部的变量。也就是说，作用域链就像只能往上不能往下的阶梯。我们看段代码理解12345678var name = "window";var age = 20;dmeo();function demo()&#123; var age = 21; console.log(name); // window console.log(age); //21&#125;在执行 demo() 函数时，就会创建一个通往全局作用域链，保存着当前作用域的变量，以便查找返回。在执行 console.log( name ) 这段代码时，会搜寻当前作用域( demo函数 ) 中是否存在 name 变量，因当前作用域不存在，所以在往上找到全局变量 name ，因此返回 window;在执行 console.log( age ) 这段代码时， 也会搜寻 当前作用域(demo函数) 中是否存在 age 变量，因为存在，所以返回 21。既然机制是只能往上读， 那么考虑一个问题，怎么在外部读取内部函数的变量呢？办法不是没有，稍微变通下即可。这就需要用到闭包的概念，12345678910111213function f1()&#123; var num = 0 ; //定义内部函数 function f2()&#123; return num + 1; &#125; //返回 f2函数引用 retufn f2; &#125;// bar 变量也指向 f2 函数，在此也是一个闭包var bar = f1();//执行bar(); // 1;我们知道，函数中的变量会随着函数的执行完毕后会被销毁。而如上代码，f1()函数执行完毕后，将f2函数赋值给一个全局变量，而f2函数的变量又依赖f1的num变量，因此，f1中的num变量并不会随着f1的函数执行完毕后而销毁。1234567891011var name = "the window"; var obj = &#123; name : 'the obj', getName : function()&#123; return funciton()&#123; return this.name; &#125; &#125;&#125;//执行 getName返回的函数alert(obj.getName()());我们看调用函数分析， 分成两部分执行。 先来看 obj.getName(); 此时getName函数由 obj对象调用，因此this的值是 obj。 但此时并不是输出而是返回一个函数。再加上一个(); 执行返回的函数，但此时返回的函数并没有任何对象调用，当不是对象本身调用，this的值会被提升到 window对象。因此输出的是 “the window”1234567891011var name = "the Window";var obj = &#123; name : "the obj", getName : funciton()&#123; var that = this; return function()&#123; return that.name; &#125; &#125;&#125;//执行 getName 返回的函数alert(obj.getName()());看了上面的题目，这个应该小意思吧，你说呢 ？]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>匿名函数</tag>
        <tag>嵌套函数</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 535种方式！实现页面重载]]></title>
    <url>%2F2019%2F01%2F05%2F1%2F</url>
    <content type="text"><![CDATA[下文整理了535种方法来实现刷新一下页面，没有验证，权做餐后谈资收藏一下！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535location = locationlocation = location.hreflocation = window.locationlocation = self.locationlocation = window.location.hreflocation = self.location.hreflocation = location['href']location = window['location']location = window['location'].hreflocation = window['location']['href']location = window.location['href']location = self['location']location = self['location'].hreflocation = self['location']['href']location = self.location['href']location.assign(location)location.replace(location)window.location.assign(location)window.location.replace(location)self.location.assign(location)self.location.replace(location)location['assign'](location)location['replace'](location)window.location['assign'](location)window.location['replace'](location)window['location'].assign(location)window['location'].replace(location)window['location']['assign'](location)window['location']['replace'](location)self.location['assign'](location)self.location['replace'](location)self['location'].assign(location)self['location'].replace(location)self['location']['assign'](location)self['location']['replace'](location)location.href = locationlocation.href = location.hreflocation.href = window.locationlocation.href = self.locationlocation.href = window.location.hreflocation.href = self.location.hreflocation.href = location['href']location.href = window['location']location.href = window['location'].hreflocation.href = window['location']['href']location.href = window.location['href']location.href = self['location']location.href = self['location'].hreflocation.href = self['location']['href']location.href = self.location['href']location.assign(location.href)location.replace(location.href)window.location.assign(location.href)window.location.replace(location.href)self.location.assign(location.href)self.location.replace(location.href)location['assign'](location.href)location['replace'](location.href)window.location['assign'](location.href)window.location['replace'](location.href)window['location'].assign(location.href)window['location'].replace(location.href)window['location']['assign'](location.href)window['location']['replace'](location.href)self.location['assign'](location.href)self.location['replace'](location.href)self['location'].assign(location.href)self['location'].replace(location.href)self['location']['assign'](location.href)self['location']['replace'](location.href)window.location = locationwindow.location = location.hrefwindow.location = window.locationwindow.location = self.locationwindow.location = window.location.hrefwindow.location = self.location.hrefwindow.location = location['href']window.location = window['location']window.location = window['location'].hrefwindow.location = window['location']['href']window.location = window.location['href']window.location = self['location']window.location = self['location'].hrefwindow.location = self['location']['href']window.location = self.location['href']location.assign(window.location)location.replace(window.location)window.location.assign(window.location)window.location.replace(window.location)self.location.assign(window.location)self.location.replace(window.location)location['assign'](window.location)location['replace'](window.location)window.location['assign'](window.location)window.location['replace'](window.location)window['location'].assign(window.location)window['location'].replace(window.location)window['location']['assign'](window.location)window['location']['replace'](window.location)self.location['assign'](window.location)self.location['replace'](window.location)self['location'].assign(window.location)self['location'].replace(window.location)self['location']['assign'](window.location)self['location']['replace'](window.location)self.location = locationself.location = location.hrefself.location = window.locationself.location = self.locationself.location = window.location.hrefself.location = self.location.hrefself.location = location['href']self.location = window['location']self.location = window['location'].hrefself.location = window['location']['href']self.location = window.location['href']self.location = self['location']self.location = self['location'].hrefself.location = self['location']['href']self.location = self.location['href']location.assign(self.location)location.replace(self.location)window.location.assign(self.location)window.location.replace(self.location)self.location.assign(self.location)self.location.replace(self.location)location['assign'](self.location)location['replace'](self.location)window.location['assign'](self.location)window.location['replace'](self.location)window['location'].assign(self.location)window['location'].replace(self.location)window['location']['assign'](self.location)window['location']['replace'](self.location)self.location['assign'](self.location)self.location['replace'](self.location)self['location'].assign(self.location)self['location'].replace(self.location)self['location']['assign'](self.location)self['location']['replace'](self.location)window.location.href = locationwindow.location.href = location.hrefwindow.location.href = window.locationwindow.location.href = self.locationwindow.location.href = window.location.hrefwindow.location.href = self.location.hrefwindow.location.href = location['href']window.location.href = window['location']window.location.href = window['location'].hrefwindow.location.href = window['location']['href']window.location.href = window.location['href']window.location.href = self['location']window.location.href = self['location'].hrefwindow.location.href = self['location']['href']window.location.href = self.location['href']location.assign(window.location.href)location.replace(window.location.href)window.location.assign(window.location.href)window.location.replace(window.location.href)self.location.assign(window.location.href)self.location.replace(window.location.href)location['assign'](window.location.href)location['replace'](window.location.href)window.location['assign'](window.location.href)window.location['replace'](window.location.href)window['location'].assign(window.location.href)window['location'].replace(window.location.href)window['location']['assign'](window.location.href)window['location']['replace'](window.location.href)self.location['assign'](window.location.href)self.location['replace'](window.location.href)self['location'].assign(window.location.href)self['location'].replace(window.location.href)self['location']['assign'](window.location.href)self['location']['replace'](window.location.href)self.location.href = locationself.location.href = location.hrefself.location.href = window.locationself.location.href = self.locationself.location.href = window.location.hrefself.location.href = self.location.hrefself.location.href = location['href']self.location.href = window['location']self.location.href = window['location'].hrefself.location.href = window['location']['href']self.location.href = window.location['href']self.location.href = self['location']self.location.href = self['location'].hrefself.location.href = self['location']['href']self.location.href = self.location['href']location.assign(self.location.href)location.replace(self.location.href)window.location.assign(self.location.href)window.location.replace(self.location.href)self.location.assign(self.location.href)self.location.replace(self.location.href)location['assign'](self.location.href)location['replace'](self.location.href)window.location['assign'](self.location.href)window.location['replace'](self.location.href)window['location'].assign(self.location.href)window['location'].replace(self.location.href)window['location']['assign'](self.location.href)window['location']['replace'](self.location.href)self.location['assign'](self.location.href)self.location['replace'](self.location.href)self['location'].assign(self.location.href)self['location'].replace(self.location.href)self['location']['assign'](self.location.href)self['location']['replace'](self.location.href)location['href'] = locationlocation['href'] = location.hreflocation['href'] = window.locationlocation['href'] = self.locationlocation['href'] = window.location.hreflocation['href'] = self.location.hreflocation['href'] = location['href']location['href'] = window['location']location['href'] = window['location'].hreflocation['href'] = window['location']['href']location['href'] = window.location['href']location['href'] = self['location']location['href'] = self['location'].hreflocation['href'] = self['location']['href']location['href'] = self.location['href']location.assign(location['href'])location.replace(location['href'])window.location.assign(location['href'])window.location.replace(location['href'])self.location.assign(location['href'])self.location.replace(location['href'])location['assign'](location['href'])location['replace'](location['href'])window.location['assign'](location['href'])window.location['replace'](location['href'])window['location'].assign(location['href'])window['location'].replace(location['href'])window['location']['assign'](location['href'])window['location']['replace'](location['href'])self.location['assign'](location['href'])self.location['replace'](location['href'])self['location'].assign(location['href'])self['location'].replace(location['href'])self['location']['assign'](location['href'])self['location']['replace'](location['href'])window['location'] = locationwindow['location'] = location.hrefwindow['location'] = window.locationwindow['location'] = self.locationwindow['location'] = window.location.hrefwindow['location'] = self.location.hrefwindow['location'] = location['href']window['location'] = window['location']window['location'] = window['location'].hrefwindow['location'] = window['location']['href']window['location'] = window.location['href']window['location'] = self['location']window['location'] = self['location'].hrefwindow['location'] = self['location']['href']window['location'] = self.location['href']location.assign(window['location'])location.replace(window['location'])window.location.assign(window['location'])window.location.replace(window['location'])self.location.assign(window['location'])self.location.replace(window['location'])location['assign'](window['location'])location['replace'](window['location'])window.location['assign'](window['location'])window.location['replace'](window['location'])window['location'].assign(window['location'])window['location'].replace(window['location'])window['location']['assign'](window['location'])window['location']['replace'](window['location'])self.location['assign'](window['location'])self.location['replace'](window['location'])self['location'].assign(window['location'])self['location'].replace(window['location'])self['location']['assign'](window['location'])self['location']['replace'](window['location'])window['location'].href = locationwindow['location'].href = location.hrefwindow['location'].href = window.locationwindow['location'].href = self.locationwindow['location'].href = window.location.hrefwindow['location'].href = self.location.hrefwindow['location'].href = location['href']window['location'].href = window['location']window['location'].href = window['location'].hrefwindow['location'].href = window['location']['href']window['location'].href = window.location['href']window['location'].href = self['location']window['location'].href = self['location'].hrefwindow['location'].href = self['location']['href']window['location'].href = self.location['href']location.assign(window['location'].href)location.replace(window['location'].href)window.location.assign(window['location'].href)window.location.replace(window['location'].href)self.location.assign(window['location'].href)self.location.replace(window['location'].href)location['assign'](window['location'].href)location['replace'](window['location'].href)window.location['assign'](window['location'].href)window.location['replace'](window['location'].href)window['location'].assign(window['location'].href)window['location'].replace(window['location'].href)window['location']['assign'](window['location'].href)window['location']['replace'](window['location'].href)self.location['assign'](window['location'].href)self.location['replace'](window['location'].href)self['location'].assign(window['location'].href)self['location'].replace(window['location'].href)self['location']['assign'](window['location'].href)self['location']['replace'](window['location'].href)window['location']['href'] = locationwindow['location']['href'] = location.hrefwindow['location']['href'] = window.locationwindow['location']['href'] = self.locationwindow['location']['href'] = window.location.hrefwindow['location']['href'] = self.location.hrefwindow['location']['href'] = location['href']window['location']['href'] = window['location']window['location']['href'] = window['location'].hrefwindow['location']['href'] = window['location']['href']window['location']['href'] = window.location['href']window['location']['href'] = self['location']window['location']['href'] = self['location'].hrefwindow['location']['href'] = self['location']['href']window['location']['href'] = self.location['href']location.assign(window['location']['href'])location.replace(window['location']['href'])window.location.assign(window['location']['href'])window.location.replace(window['location']['href'])self.location.assign(window['location']['href'])self.location.replace(window['location']['href'])location['assign'](window['location']['href'])location['replace'](window['location']['href'])window.location['assign'](window['location']['href'])window.location['replace'](window['location']['href'])window['location'].assign(window['location']['href'])window['location'].replace(window['location']['href'])window['location']['assign'](window['location']['href'])window['location']['replace'](window['location']['href'])self.location['assign'](window['location']['href'])self.location['replace'](window['location']['href'])self['location'].assign(window['location']['href'])self['location'].replace(window['location']['href'])self['location']['assign'](window['location']['href'])self['location']['replace'](window['location']['href'])window.location['href'] = locationwindow.location['href'] = location.hrefwindow.location['href'] = window.locationwindow.location['href'] = self.locationwindow.location['href'] = window.location.hrefwindow.location['href'] = self.location.hrefwindow.location['href'] = location['href']window.location['href'] = window['location']window.location['href'] = window['location'].hrefwindow.location['href'] = window['location']['href']window.location['href'] = window.location['href']window.location['href'] = self['location']window.location['href'] = self['location'].hrefwindow.location['href'] = self['location']['href']window.location['href'] = self.location['href']location.assign(window.location['href'])location.replace(window.location['href'])window.location.assign(window.location['href'])window.location.replace(window.location['href'])self.location.assign(window.location['href'])self.location.replace(window.location['href'])location['assign'](window.location['href'])location['replace'](window.location['href'])window.location['assign'](window.location['href'])window.location['replace'](window.location['href'])window['location'].assign(window.location['href'])window['location'].replace(window.location['href'])window['location']['assign'](window.location['href'])window['location']['replace'](window.location['href'])self.location['assign'](window.location['href'])self.location['replace'](window.location['href'])self['location'].assign(window.location['href'])self['location'].replace(window.location['href'])self['location']['assign'](window.location['href'])self['location']['replace'](window.location['href'])self['location'] = locationself['location'] = location.hrefself['location'] = window.locationself['location'] = self.locationself['location'] = window.location.hrefself['location'] = self.location.hrefself['location'] = location['href']self['location'] = window['location']self['location'] = window['location'].hrefself['location'] = window['location']['href']self['location'] = window.location['href']self['location'] = self['location']self['location'] = self['location'].hrefself['location'] = self['location']['href']self['location'] = self.location['href']location.assign(self['location'])location.replace(self['location'])window.location.assign(self['location'])window.location.replace(self['location'])self.location.assign(self['location'])self.location.replace(self['location'])location['assign'](self['location'])location['replace'](self['location'])window.location['assign'](self['location'])window.location['replace'](self['location'])window['location'].assign(self['location'])window['location'].replace(self['location'])window['location']['assign'](self['location'])window['location']['replace'](self['location'])self.location['assign'](self['location'])self.location['replace'](self['location'])self['location'].assign(self['location'])self['location'].replace(self['location'])self['location']['assign'](self['location'])self['location']['replace'](self['location'])self['location'].href = locationself['location'].href = location.hrefself['location'].href = window.locationself['location'].href = self.locationself['location'].href = window.location.hrefself['location'].href = self.location.hrefself['location'].href = location['href']self['location'].href = window['location']self['location'].href = window['location'].hrefself['location'].href = window['location']['href']self['location'].href = window.location['href']self['location'].href = self['location']self['location'].href = self['location'].hrefself['location'].href = self['location']['href']self['location'].href = self.location['href']location.assign(self['location'].href)location.replace(self['location'].href)window.location.assign(self['location'].href)window.location.replace(self['location'].href)self.location.assign(self['location'].href)self.location.replace(self['location'].href)location['assign'](self['location'].href)location['replace'](self['location'].href)window.location['assign'](self['location'].href)window.location['replace'](self['location'].href)window['location'].assign(self['location'].href)window['location'].replace(self['location'].href)window['location']['assign'](self['location'].href)window['location']['replace'](self['location'].href)self.location['assign'](self['location'].href)self.location['replace'](self['location'].href)self['location'].assign(self['location'].href)self['location'].replace(self['location'].href)self['location']['assign'](self['location'].href)self['location']['replace'](self['location'].href)self['location']['href'] = locationself['location']['href'] = location.hrefself['location']['href'] = window.locationself['location']['href'] = self.locationself['location']['href'] = window.location.hrefself['location']['href'] = self.location.hrefself['location']['href'] = location['href']self['location']['href'] = window['location']self['location']['href'] = window['location'].hrefself['location']['href'] = window['location']['href']self['location']['href'] = window.location['href']self['location']['href'] = self['location']self['location']['href'] = self['location'].hrefself['location']['href'] = self['location']['href']self['location']['href'] = self.location['href']location.assign(self['location']['href'])location.replace(self['location']['href'])window.location.assign(self['location']['href'])window.location.replace(self['location']['href'])self.location.assign(self['location']['href'])self.location.replace(self['location']['href'])location['assign'](self['location']['href'])location['replace'](self['location']['href'])window.location['assign'](self['location']['href'])window.location['replace'](self['location']['href'])window['location'].assign(self['location']['href'])window['location'].replace(self['location']['href'])window['location']['assign'](self['location']['href'])window['location']['replace'](self['location']['href'])self.location['assign'](self['location']['href'])self.location['replace'](self['location']['href'])self['location'].assign(self['location']['href'])self['location'].replace(self['location']['href'])self['location']['assign'](self['location']['href'])self['location']['replace'](self['location']['href'])self.location['href'] = locationself.location['href'] = location.hrefself.location['href'] = window.locationself.location['href'] = self.locationself.location['href'] = window.location.hrefself.location['href'] = self.location.hrefself.location['href'] = location['href']self.location['href'] = window['location']self.location['href'] = window['location'].hrefself.location['href'] = window['location']['href']self.location['href'] = window.location['href']self.location['href'] = self['location']self.location['href'] = self['location'].hrefself.location['href'] = self['location']['href']self.location['href'] = self.location['href']location.assign(self.location['href'])location.replace(self.location['href'])window.location.assign(self.location['href'])window.location.replace(self.location['href'])self.location.assign(self.location['href'])self.location.replace(self.location['href'])location['assign'](self.location['href'])location['replace'](self.location['href'])window.location['assign'](self.location['href'])window.location['replace'](self.location['href'])window['location'].assign(self.location['href'])window['location'].replace(self.location['href'])window['location']['assign'](self.location['href'])window['location']['replace'](self.location['href'])self.location['assign'](self.location['href'])self.location['replace'](self.location['href'])self['location'].assign(self.location['href'])self['location'].replace(self.location['href'])self['location']['assign'](self.location['href'])self['location']['replace'](self.location['href'])location.reload()location['reload']()window.location.reload()window['location'].reload()window.location['reload']()window['location']['reload']()self.location.reload()self['location'].reload()self.location['reload']()self['location']['reload']()]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>页面重载</tag>
      </tags>
  </entry>
</search>
